/** Linked list implementation of the lock coupling template for linearizable dictionaries. */

options "-abspreds -simplearrays -propreads -stratify"

include "lock-coupling.spl"
include "array_util.spl"

function KS() returns (res: Set<K>)
{
  { k: K :: k != top && k != bot }
}
  
/** Definition of a node */

struct Node {
  var data: K;
  var next: Node;
  var sentinel: Bool;
}

/** Definition of heap representation, hrep */

define hrepSpatial(x) {
  acc(x)
}

define heapGood(x) {
  x.next != x
}

function edgeFn(x: Node, inflow: Map<Node, Multiset>) returns (res: Map<Node, FlowDom>)
  requires acc(x)
{
  { n1: Node ::
      (n1 != x.next || n1 == null ? domZero :
      { k: K :: lt(x.data, k) ? inflow[x][k] : 0 @(noinst k)})
  }
}

function contents(x: Node) returns (res: Set<K>)
  requires acc(x)
{
  x.sentinel ? {} : {x.data}
}

define hrep(first, x, I) {
  hrepSpatial(x) &*& heapGood(x) &*& I.dom == {x}
  && (x.sentinel == (x.data == top || x.data == bot))
  && I.inf[x][top] > 0
  && (forall k1: K :: I.inf[x][k1] == 1 || I.inf[x][k1] == 0)
  && (forall k1: K :: le(x.data, k1) && k1 in KS ==> I.inf[x][k1] == 1)
  && I.out == edgeFn(x, I.inf)
  && (x.next == null && x.data == top
    || x.next != null && x.data != top)
  && (x == first ==> x.data == bot)
}


// The good condition
define searchStrInv(first, x, I, C) {
    C <= KS
      && (forall k1 in KS :: x == first ==> in_outset(k1, I, x.next))
}

define node(first, x, I, C) {
  hrep(first, x, I) &*& (searchStrInv(first, x, I, C) && C == contents(x))
}

/** Lemmas and predicates used by Iris */

pure predicate nodeinv(first: Node, n: Node, I: Interface, C: Set<K>) {
  intValid(I)
  && C <= KS
  && (n == first ==> (forall k1 in KS :: in_outsets(k1, I)))
}

lemma node_implies_nodeinv(first: Node, n: Node, I: Interface, C: Set<K>)
  requires node(first, n, I, C) &*& intValid(I)
  pure ensures nodeinv(first, n, I, C)
{
  pure assert forall k1: K :: k1 in KS ==> n == first ==> in_outsets(k1, I) with {
    pure assert k1 in KS ==> n == first ==> in_outset(k1, I, n.next);
  }
}

/** Begin programs */

/** Initialize data structure */
procedure init()
  returns (first: Node, ghost last: Node, ghost I1: Interface, ghost I2: Interface)
  ensures node(first, first, I1, {}) &*& node(first, last, I2, {})
  ensures globalinv(first, intComp(I1, I2));
  ensures intValid(intComp(I1, I2));
{
  last := new Node;
  last.next := null;
  last.data := top;
  last.sentinel := true;

  first := new Node;
  first.next := last;
  first.data := bot;
  first.sentinel := true;

  
  ghost var fst_inf := { n: Node :: n == first ? { k: K :: 1 } : domZero };
  I1 := int(fst_inf, edgeFn(first, fst_inf), {first});

  assert node(first, first, I1, {}) &*& acc(last);
  
  ghost var lst_inf := { n: Node :: n == last ? { k: K :: 1 } : domZero };
  I2 := int(lst_inf, edgeFn(last, lst_inf), {last});

  assert node(first, last, I2, {}) &*& acc(first);

  pure assert forall k: K :: domMinus(I2.inf[last], I1.out[last])[k] >= 0 with {
    pure assert I2.inf[last][k] - I1.out[last][k] >= 0;
  }

  pure assert forall k: K :: domMinus(I1.inf[first], I2.out[first])[k] >= 0 with {
    pure assert I1.inf[first][k] - I2.out[first][k] >= 0;
  }

  pure assert domValid(domMinus(I2.inf[last], I1.out[last]));
  pure assert domValid(domMinus(I1.inf[first], I2.out[first]));

  pure assert forall k: K :: I2.inf[last][k] == domPlus(I1.out[last], domMinus(I2.inf[last], I1.out[last]))[k] with {
    pure assert I2.inf[last][k] == I1.out[last][k] + (I2.inf[last][k] - I1.out[last][k]);
    pure assert I2.inf[last][k] == I1.out[last][k] + domMinus(I2.inf[last], I1.out[last])[k];
  }

  pure assert forall k: K :: I1.inf[first][k] == domPlus(I2.out[first], domMinus(I1.inf[first], I2.out[first]))[k] with {
    pure assert I1.inf[first][k] == I2.out[first][k] + (I1.inf[first][k] - I2.out[first][k]);
    pure assert I1.inf[first][k] == I2.out[first][k] + domMinus(I1.inf[first], I2.out[first])[k];
  }
  pure assert intComposable(I1, I2);

  ghost var I := intComp(I1, I2);
  pure assert forall n: Node, k: K :: n !in I.dom ==> I.out[n][k] == domZero[k] with {
    if (n !in I.dom) {
      pure assert I.out[n][k] == domPlus(I1.out[n], I2.out[n])[k];
      pure assert I.out[n][k] == I1.out[n][k] + I2.out[n][k];
    }
  }
}


/** findNext */
procedure findNext(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>, implicit ghost first: Node)
  returns (n: Node, res: Bool)
  requires node(first, x, Ix, C) &*& intValid(Ix)
  requires in_inset(k, Ix, x)
  ensures node(first, x, Ix, C)
  ensures n != null ==> in_outset(k, Ix, n)
  ensures n == null ==> (forall y: Node :: !(in_outset(k, Ix, y)))
  ensures res == (k in C)
{
  if (x.next == null) {
    return null, false;
  } else {
    if (le(k, x.data)) {
      return null, x.data == k && !x.sentinel;
    } else {
      return x.next, false;
    }
  }
}

/** search */
procedure search(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>, implicit ghost first: Node)
  returns (res: Bool, implicit ghost C1: Set<K>)
  requires node(first, x, Ix, C) &*& intValid(Ix)
  requires in_inset(k, Ix, x) && (forall y: Node :: !(in_outset(k, Ix, y)))
  ensures node(first, x, Ix, C1)
  // decisiveOpSpec(x, Ix1, res, k):
  ensures (C1 == C && (res == k in C))
{
  if (!x.sentinel && k == x.data)
    return true;
  else
    return false;
}


/** insert */
procedure insert(p: Node, n: Node, k: K,
                 Ip: Interface, In: Interface, Ipn: Interface,
                 implicit ghost Cpn: Set<K>, implicit ghost first: Node)
  returns (Ip1: Interface, In1: Interface, Im1: Interface, Ipnm1: Interface, ghost m: Node,
           Cpnm1: Set<K>)
  requires k in KS
  requires node(first, p, Ip, contents(p)) &*& node(first, n, In, contents(n)) &*& hrepSpatial(m)
  requires Ipn == intComp(Ip, In) && intValid(Ipn) 
  requires Ipn.out[m] == domZero
  requires m != first
  requires n != first
  requires Cpn == contents(p) ++ contents(n)
  requires k !in contents(n)
  requires in_outset(k, Ip, n);
  requires in_inset(k, In, n) && (forall y: Node :: !(in_outset(k, In, y)))
  ensures node(first, p, Ip1, contents(p)) &*& node(first, n, In1, contents(n)) &*& node(first, m, Im1, contents(m))
  ensures intValid(Ip1) &*& intValid(In1) &*& intValid(Im1)
  ensures Ipnm1 == intComp(Ip1, intComp(Im1, In1))
  ensures intLeq(Ipn, Ipnm1)
  ensures Cpnm1 == contents(n) ++ contents(m) ++ contents(p);
  // decisiveOpSpec(x, Ix1, res, k):
    ensures Cpnm1 == Cpn ++ {k}
{
  m.data := k;
  m.next := n;
  m.sentinel := false;
  p.next := m;  

  // Proof - not pretty but almost all of this is just manual expansion of definitions

  pure assert Ipn.out[m][top] == 0;
  pure assert Ipn.out[m][top] == domPlus(Ip.out[m], In.out[m])[top];
  pure assert Ipn.out[m][top] == Ip.out[m][top] + In.out[m][top];  
  pure assert n.next != m; 

  // Define Ip1
  Ip1 := int(Ip.inf, edgeFn(p, Ip.inf), {p});
  pure assert intValid(Ip1);
  
  //pure assert Ip.out[m] == domZero;
  
  // Define Im1
  ghost var minf1 := { n1: Node :: n1 == m ? { k1: K :: lt(p.data, k1) ? 1 : 0}: domZero };
  Im1 := int(minf1, edgeFn(m, minf1), {m});
  pure assert intValid(Im1);
  //assert node(m, Im1, {k}) &*& acc(p) &*& acc(n);

  
  // Define In1
  ghost var ninf1 := { n1: Node :: n1 == n ? { k1: K :: In.inf[n][k1] == 1 && le(k1, p.data) || lt(k, k1) ? 1 : 0} : domZero };

  In1 := int(ninf1, edgeFn(n, ninf1), In.dom);
  pure assert forall n1: Node, k1: K :: ninf1[n1][k1] >= 0 with {
    pure assert n1 != n ==> ninf1[n1][k1] == 0;
    if (n == n1 && In.inf[n][k1] == 1 && le(k1, p.data) || lt(k, k1)) {
      pure assert ninf1[n][k1] == 1;
    } else {
      pure assert ninf1[n1][k1] == 0;
    }
  }
  pure assert intValid(In1);
  //assert node(n, In1, Cn) &*& acc(p) &*& acc(m);

  // intComp(In1, Im1)
  pure assert forall n1: Node, k1: K ::
    n1 in In1.dom ==> In1.inf[n1][k1] == domPlus(Im1.out[n1], domMinus(In1.inf[n1], Im1.out[n1]))[k1]
    with {
      pure assert
        In1.inf[n1][k1] == Im1.out[n1][k1] + (In1.inf[n1][k1] - Im1.out[n1][k1]);
      pure assert In1.inf[n1][k1] == Im1.out[n1][k1] + domMinus(In1.inf[n1], Im1.out[n1])[k1];
  }
  pure assert forall n1: Node, k1: K ::
    n1 in Im1.dom ==> Im1.inf[n1][k1] == domPlus(In1.out[n1], domMinus(Im1.inf[n1], In1.out[n1]))[k1]
    with {
      if (n1 == m) {
        pure assert
          Im1.inf[n1][k1] == In1.out[n1][k1] + (Im1.inf[n1][k1] - In1.out[n1][k1]);
          pure assert Im1.inf[n1][k1] == In1.out[n1][k1] + domMinus(Im1.inf[n1], In1.out[n1])[k1];
      }
  }

  pure assert forall n1: Node :: n1 in Im1.dom ==> domValid(domMinus(Im1.inf[n1], In1.out[n1])) with {
    if (n1 in Im1.dom) {
      pure assert forall k: K :: domMinus(Im1.inf[n1], In1.out[n1])[k] >= 0 with {
        pure assert Im1.inf[n1][k] -  In1.out[n1][k] >= 0;
      }
    }
  }

  pure assert forall n1: Node :: n1 in In1.dom ==> domValid(domMinus(In1.inf[n1], Im1.out[n1])) with {
    if (n1 in In1.dom) {
      pure assert forall k: K :: domMinus(In1.inf[n1], Im1.out[n1])[k] >= 0 with {
        pure assert In1.inf[n1][k] - Im1.out[n1][k] >= 0;
      }
    }
  }

  lemma_int_comp_fold(Im1, In1);

  ghost var Inm1 := intComp(In1, Im1);
  intComp_comm(In1, Im1);
  lemma_int_comp_unfold(Im1, In1);

  pure assert forall n1: Node, k1: K ::
    n1 in Ip1.dom ==> Ip1.inf[n1][k1] == domPlus(Inm1.out[n1], domMinus(Ip1.inf[n1], Inm1.out[n1]))[k1] with {
      if (n1 == p) {
        pure assert Inm1.out[n1][k1] == domPlus(Im1.out[n1], In1.out[n1])[k1];
        pure assert Inm1.out[n1][k1] == Im1.out[n1][k1] + In1.out[n1][k1];
        pure assert Ip1.inf[n1][k1] == Inm1.out[n1][k1] + (Ip1.inf[n1][k1] - Inm1.out[n1][k1]);
        pure assert Ip1.inf[n1][k1] == Inm1.out[n1][k1] + domMinus(Ip1.inf[n1], Inm1.out[n1])[k1];
      }
  }
    
  pure assert forall n1: Node, k1: K ::
    n1 in Inm1.dom ==> Inm1.inf[n1][k1] == domPlus(Ip1.out[n1], domMinus(Inm1.inf[n1], Ip1.out[n1]))[k1] with {
      if (n1 in Inm1.dom) {
        pure assert n1 == n ==> In1.inf[n1][k1] == domPlus(Inm1.inf[n1], Im1.out[n1])[k1];
        pure assert n1 == m ==> Im1.inf[n1][k1] == domPlus(Inm1.inf[n1], In1.out[n1])[k1];
        pure assert n1 == m ==> Im1.inf[n1][k1] == Inm1.inf[n1][k1] + In1.out[n1][k1];
        pure assert Inm1.inf[n1][k1] == Ip1.out[n1][k1] + (Inm1.inf[n1][k1] - Ip1.out[n1][k1]);
        pure assert Inm1.inf[n1][k1] == Ip1.out[n1][k1] + domMinus(Inm1.inf[n1], Ip1.out[n1])[k1];
      }
  }

  pure assert forall n1: Node :: n1 in Ip1.dom ==> domValid(domMinus(Ip1.inf[n1], Inm1.out[n1])) with {
    if (n1 in Ip1.dom) {
      pure assert forall k: K :: domMinus(Ip1.inf[n1], Inm1.out[n1])[k] >= 0 with {
        pure assert Inm1.out[n1] == domPlus(Im1.out[n1], In1.out[n1]);
        pure assert Inm1.out[n1][k] == domPlus(Im1.out[n1], In1.out[n1])[k];
        pure assert Inm1.out[n1][k] == Im1.out[n1][k] + In1.out[n1][k];
        pure assert Ip1.inf[n1][k] - Inm1.out[n1][k] >= 0;
      }
    }
  }

  pure assert forall n1: Node :: n1 in Inm1.dom ==> domValid(domMinus(Inm1.inf[n1], Ip1.out[n1])) with {
    if (n1 in Inm1.dom) {
      pure assert forall k: K :: domMinus(Inm1.inf[n1], Ip1.out[n1])[k] >= 0 with {
        pure assert n1 in In1.dom ==> In1.inf[n1][k] == domPlus(Inm1.inf[n1], Im1.out[n1])[k];
        pure assert n1 in In1.dom ==> In1.inf[n1][k] == Inm1.inf[n1][k] + Im1.out[n1][k];
        pure assert n1 in Im1.dom ==> Im1.inf[n1][k] == domPlus(Inm1.inf[n1], In1.out[n1])[k];
        pure assert n1 in Im1.dom ==> Im1.inf[n1][k] == Inm1.inf[n1][k] + In1.out[n1][k];
        pure assert Inm1.inf[n1][k] - Ip1.out[n1][k] >= 0;
      }
    }
  }

  lemma_int_comp_fold(Ip1, intComp(Im1, In1));

  lemma_int_comp_unfold(Ip1, intComp(Im1, In1));

  Ipnm1 := intComp(Ip1, intComp(Im1, In1));

  // assert "test" node(first, p, Ip1, contents(p)) &*& hrepSpatial(n) &*& hrepSpatial(m);
  // assert "test" node(first, n, In1, contents(n)) &*& hrepSpatial(p) &*& hrepSpatial(m);
  // assert "test" node(first, m, Im1, contents(m)) &*& hrepSpatial(n) &*& hrepSpatial(p);
  
  pure assert intLeq(Ipn, Ipnm1) with {
    lemma_int_comp_unfold(Ip, In);
    pure assert (forall n1: Node, k1: K :: n1 in Ipn.dom ==> Ipn.inf[n1][k1] == Ipnm1.inf[n1][k1]) with {
      if (n1 in Ipn.dom) {
        pure assert n1 == p ==> Ip.inf[n1][k1] == domPlus(Ipn.inf[n1], In.out[n1])[k1];
        pure assert n1 == p ==> Ip.inf[n1][k1] == Ipn.inf[n1][k1] + In.out[n1][k1];
        pure assert n1 == n ==> In.inf[n1][k1] == domPlus(Ipn.inf[n1], Ip.out[n1])[k1];
        pure assert n1 == n ==> In.inf[n1][k1] == Ipn.inf[n1][k1] + Ip.out[n1][k1];

        pure assert n1 == n ==> In1.inf[n1][k1] == domPlus(Inm1.inf[n1], Im1.out[n1])[k1];
        pure assert n1 == n ==> In1.inf[n1][k1] == Inm1.inf[n1][k1] + Im1.out[n1][k1];
        pure assert n1 == n ==> Inm1.inf[n1][k1] == domPlus(Ipnm1.inf[n1], Ip1.out[n1])[k1];
        pure assert n1 == n ==> Inm1.inf[n1][k1] == Ipnm1.inf[n1][k1] + Ip1.out[n1][k1];

        pure assert n1 == p ==> Ip1.inf[n1][k1] == domPlus(Ipnm1.inf[n1], Inm1.out[n1])[k1];
        pure assert n1 == p ==> Ip1.inf[n1][k1] == Ipnm1.inf[n1][k1] + Inm1.out[n1][k1];

        pure assert Inm1.out[p][k1] == domPlus(Im1.out[p], In1.out[p])[k1];
        pure assert Inm1.out[p][k1] == Im1.out[p][k1] + In1.out[p][k1];
        
      }
    }

    pure assert (forall n1: Node, k1: K :: n1 !in Ipn.dom ==> Ipn.out[n1][k1] == Ipnm1.out[n1][k1]) with {
      if (n1 !in Ipn.dom) {
        pure assert Ipn.out[n1][k1] == domPlus(Ip.out[n1], In.out[n1])[k1];
        pure assert Ipn.out[n1][k1] == Ip.out[n1][k1] + In.out[n1][k1];

        pure assert Inm1.out[m][k1] == 0;
        pure assert n1 != m ==> Inm1.out[n1][k1] == domPlus(Im1.out[n1], In1.out[n1])[k1];
        pure assert n1 != m ==> Inm1.out[n1][k1] == Im1.out[n1][k1] + In1.out[n1][k1];

        pure assert n1 != m ==> Ipnm1.out[n1][k1] == domPlus(Ip1.out[n1], Inm1.out[n1])[k1];
        pure assert n1 != m ==> Ipnm1.out[n1][k1] == Ip1.out[n1][k1] + Inm1.out[n1][k1];
      }
    }
  }
  Cpnm1 := contents(n) ++ contents(m) ++ contents(p);
}

