/** Linked list implementation of the lock coupling template for linearizable dictionaries. */

options "-abspreds -simplearrays -propreads -stratify"

include "lock-coupling.spl"
include "array_util.spl"

pure function KS() returns (res: Set<K>)
{
  { k: K :: k != top && k != bot }
}
  
/** Definition of a node */

struct Node {
  var data: K;
  var next: Node;
  var sentinel: Bool;
}

/** Definition of heap representation, hrep */

define hrepSpatial(x) {
  acc(x)
}

define heapGood(x) {
  x.next != x
}

function keyset(I: Interface, n: Node) returns (res: Set<K>)
  requires acc(n)
{
  { k: K :: in_inset(k, I, n) && !(in_outset(k, I, n.next)) }
}

function edgeFn(x: Node, inflow: Map<Node, Multiset>) returns (res: Map<Node, FlowDom>)
  requires acc(x)
{
  { n1: Node ::
      (n1 != x.next || n1 == null ? domZero :
      { k: K :: lt(x.data, k) ? inflow[x][k] : 0 @(noinst k)})
  }
}

function contents(x: Node) returns (res: Set<K>)
  requires acc(x)
{
  x.sentinel ? {} : {x.data}
}

define hrep(first, x, I) {
  hrepSpatial(x) &*& heapGood(x) &*& I.dom == {x}
  && (x.sentinel == (x.data == top || x.data == bot))
  && I.inf[x][top] > 0
  && (forall k1: K :: le(x.data, k1) && k1 in KS ==> I.inf[x][k1] == 1 @(noinst k1))
  && I.out == edgeFn(x, I.inf)
  && (x.next == null && x.data == top
    || x.next != null && x.data != top)
  && (x == first ==> x.data == bot)
}

define in_keyset(k, I, x) {
  in_inset(k, I, x) && !(in_outset(k, I, x.next))
}

// The good condition
define searchStrInv(first, x, I, C) {
    C <= KS
      && (forall k1 in KS :: x == first ==> in_outset(k1, I, x.next) @(noinst k1))
      && (forall k1: K :: I.inf[x][k1] <= 1 @(noinst k1))
}

define node(first, x, I, C) {
  hrep(first, x, I) &*& (searchStrInv(first, x, I, C) && C == contents(x))
}

/** Implementation-specific lemmas needed by Iris */

lemma node_implies_nodeinv(first: Node, n: Node, I: Interface, C: Set<K>)
  requires node(first, n, I, C) &*& intValid(I)
  pure ensures nodeinv(first, n, I, C)
{
  pure assert forall k1: K :: k1 in KS ==> n == first ==> in_outsets(k1, I) with {
    pure assert k1 in KS ==> n == first ==> in_outset(k1, I, n.next);
  }
}

lemma node_sep_star(first: Node, n: Node, I_n: Interface, I_np: Interface, C: Set<K>, Cp: Set<K>)
  requires node(first, n, I_n, C) &*& node(first, n, I_np, Cp)
  ensures false
{
  
}

/** Auxiliary lemmas used below */

lemma keyset_impl(first: Node, n: Node, I: Interface, implicit ghost C: Set<K>)
  requires node(first, n, I, C)
  ensures node(first, n, I, C)
  ensures (forall k: K :: (in_keyset(k, I, n) == (k in keyset(I, n))) @(noinst k))
{
  pure assert forall k: K :: in_keyset(k, I, n) == (k in keyset(I, n)) with {
    if (k in keyset(I, n)) {
      pure assert in_inset(k, I, n);
      pure assert !(in_outsets(k, I));
    }
  }
}

/** Begin programs */

/** Initialize data structure */
procedure init()
  returns (first: Node, ghost last: Node, ghost I1: Interface, ghost I2: Interface)
  ensures node(first, first, I1, {}) &*& node(first, last, I2, {})
  ensures globalinv(first, intComp(I1, I2))
  ensures intValid(intComp(I1, I2))
  ensures Disjoint(keyset(I1, first), keyset(I2, last))
{
  last := new Node;
  last.next := null;
  last.data := top;
  last.sentinel := true;

  first := new Node;
  first.next := last;
  first.data := bot;
  first.sentinel := true;

  
  ghost var fst_inf := { n: Node :: n == first ? { k: K :: 1 } : domZero };
  I1 := int(fst_inf, edgeFn(first, fst_inf), {first});

  assert node(first, first, I1, {}) &*& acc(last);
  
  ghost var lst_inf := { n: Node :: n == last ? { k: K :: k != bot ? 1 : 0 } : domZero };
  I2 := int(lst_inf, edgeFn(last, lst_inf), {last});

  assert node(first, last, I2, {}) &*& acc(first);

  pure assert forall k: K :: domMinus(I2.inf[last], I1.out[last])[k] >= 0 with {
    pure assert I2.inf[last][k] - I1.out[last][k] >= 0;
  }

  pure assert forall k: K :: domMinus(I1.inf[first], I2.out[first])[k] >= 0 with {
    pure assert I1.inf[first][k] - I2.out[first][k] >= 0;
  }

  pure assert domValid(domMinus(I2.inf[last], I1.out[last]));
  pure assert domValid(domMinus(I1.inf[first], I2.out[first]));

  pure assert forall k: K :: I2.inf[last][k] == domPlus(I1.out[last], domMinus(I2.inf[last], I1.out[last]))[k] with {
    pure assert I2.inf[last][k] == I1.out[last][k] + (I2.inf[last][k] - I1.out[last][k]);
    pure assert I2.inf[last][k] == I1.out[last][k] + domMinus(I2.inf[last], I1.out[last])[k];
  }

  pure assert forall k: K :: I1.inf[first][k] == domPlus(I2.out[first], domMinus(I1.inf[first], I2.out[first]))[k] with {
    pure assert I1.inf[first][k] == I2.out[first][k] + (I1.inf[first][k] - I2.out[first][k]);
    pure assert I1.inf[first][k] == I2.out[first][k] + domMinus(I1.inf[first], I2.out[first])[k];
  }
  pure assert intComposable(I1, I2);
  ghost var I := intComp(I1, I2);

  lemma_int_comp_unfold(I1, I2);

  pure assert forall n: Node, k: K :: (n !in I.dom ==> I.out[n][k] == domZero[k]) with {
    if (n !in I.dom) {
      pure assert I.out[n][k] == domPlus(I1.out[n], I2.out[n])[k];
      pure assert I.out[n][k] == I1.out[n][k] + I2.out[n][k];
    }
  }
  pure assert forall k: K :: I.inf[first][k] > 0 with {
    pure assert I1.inf[first][k] == domPlus(I.inf[first], I2.out[first])[k];
    pure assert I1.inf[first][k] == I.inf[first][k] + I2.out[first][k];
  }
  pure assert "test" forall k: K :: I.inf[last][k] == 0 with {
    pure assert "test2" I2.inf[last][k] == domPlus(I.inf[last], I1.out[last])[k];
    pure assert "test2" I2.inf[last][k] == I.inf[last][k] + I1.out[last][k];
  }
}


/** findNext */
procedure findNext(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>, implicit ghost first: Node)
  returns (n: Node, res: Bool)
  requires node(first, x, Ix, C) &*& intValid(Ix)
  requires in_inset(k, Ix, x)
  ensures node(first, x, Ix, C)
  ensures n != null ==> in_outset(k, Ix, n)
  ensures n == null ==> (forall y: Node :: !(in_outset(k, Ix, y)))
  ensures res == (k in C)
{
  if (x.next == null) {
    return null, false;
  } else {
    if (le(k, x.data)) {
      return null, x.data == k && !x.sentinel;
    } else {
      return x.next, false;
    }
  }
}

/** search */
procedure search(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>, implicit ghost first: Node)
  returns (res: Bool, implicit ghost C1: Set<K>)
  requires node(first, x, Ix, C) &*& intValid(Ix)
  requires in_inset(k, Ix, x) && (forall y: Node :: !(in_outset(k, Ix, y)))
  ensures node(first, x, Ix, C1)
  // decisiveOpSpec(x, Ix1, res, k):
  ensures (C1 == C && (res == k in C))
{
  if (!x.sentinel && k == x.data)
    return true;
  else
    return false;
}


/** insert */
procedure insert(p: Node, n: Node, m: Node, k: K,
                 Ip: Interface, In: Interface, Ipn: Interface,
                 implicit ghost Cpn: Set<K>, implicit ghost first: Node, ks: Set<K>)
  returns (Ip1: Interface, In1: Interface, Im1: Interface, Ipnm1: Interface,
  Cpnm1: Set<K>)
  requires k in KS
  requires Disjoint(keyset(Ip, p), keyset(In, n))
  requires node(first, p, Ip, contents(p)) &*& node(first, n, In, contents(n)) &*& hrepSpatial(m)
  requires Ipn == intComp(Ip, In) && intValid(Ipn) 
  requires Ipn.out[m] == domZero
  requires m != first
  requires n != first
  requires Cpn == contents(p) ++ contents(n)
  requires k !in contents(n)
  requires in_outset(k, Ip, n);
  requires in_inset(k, In, n) && (forall y: Node :: !(in_outset(k, In, y)) @(noinst k))
  ensures node(first, p, Ip1, contents(p)) &*& node(first, n, In1, contents(n)) &*& node(first, m, Im1, contents(m))
  ensures Ipnm1 == intComp(Ip1, intComp(Im1, In1))
  ensures Ipnm1.inf[m] == domZero
  ensures intValid(Ipnm1)
  ensures intLeq(Ipn, Ipnm1)
  ensures Cpnm1 == contents(n) ++ contents(m) ++ contents(p)
  ensures old(keyset(Ip, p) ++ keyset(In, n)) == keyset(Ip1, p) ++ keyset(In1, n) ++ keyset(Im1, m)
  ensures Disjoint(keyset(Ip1, n), keyset(In1, m))
  ensures Disjoint(keyset(Ip1, n), keyset(Im1, m))
  ensures Disjoint(keyset(In1, n), keyset(Im1, m))
  // decisiveOpSpec(x, Ix1, res, k):
  ensures Cpnm1 == Cpn ++ {k}
{
  m.data := k;
  m.next := n;
  m.sentinel := false;
  p.next := m;  

  // Proof - not pretty but almost all of this is just manual expansion of definitions

  pure assert n.next != m with {
    pure assert Ipn.out[m][top] == 0;
    expand_out(m, top, Ip, In);
  }
  pure assert old(p.next) == n;

  
  // Define Ip1
  Ip1 := int(Ip.inf, edgeFn(p, Ip.inf), {p});
  pure assert intValid(Ip1);
  
  // Define Im1
  ghost var minf1 := { n1: Node :: n1 == m ? { k1: K :: lt(p.data, k1) ? 1 : 0}: domZero };
  Im1 := int(minf1, edgeFn(m, minf1), {m});
  pure assert intValid(Im1);
  
  // Define In1
  ghost var ninf1 := { n1: Node :: n1 == n ? { k1: K :: In.inf[n][k1] == 1 && (le(k1, p.data) || lt(k, k1)) ? 1 : 0} : domZero };

  In1 := int(ninf1, edgeFn(n, ninf1), In.dom);
  pure assert forall n1: Node, k1: K :: ninf1[n1][k1] >= 0 with {
    pure assert n1 != n ==> ninf1[n1][k1] == 0;
    if (n == n1 && In.inf[n][k1] == 1 && (le(k1, p.data) || lt(k, k1))) {
      pure assert ninf1[n][k1] == 1;
    } else {
      pure assert ninf1[n1][k1] == 0;
    }
  }
  pure assert intValid(In1);
  
  // intComp(In1, Im1)
  pure assert intComposable(Im1, In1) with {
  pure assert forall n1: Node, k1: K ::
    n1 in In1.dom ==> In1.inf[n1][k1] == domPlus(Im1.out[n1], domMinus(In1.inf[n1], Im1.out[n1]))[k1]
    with {
      pure assert
        In1.inf[n1][k1] == Im1.out[n1][k1] + (In1.inf[n1][k1] - Im1.out[n1][k1]);
      pure assert In1.inf[n1][k1] == Im1.out[n1][k1] + domMinus(In1.inf[n1], Im1.out[n1])[k1];
  }
  pure assert forall n1: Node, k1: K ::
    n1 in Im1.dom ==> Im1.inf[n1][k1] == domPlus(In1.out[n1], domMinus(Im1.inf[n1], In1.out[n1]))[k1]
    with {
      if (n1 == m) {
        pure assert
          Im1.inf[n1][k1] == In1.out[n1][k1] + (Im1.inf[n1][k1] - In1.out[n1][k1]);
          pure assert Im1.inf[n1][k1] == In1.out[n1][k1] + domMinus(Im1.inf[n1], In1.out[n1])[k1];
      }
  }

  pure assert forall n1: Node :: n1 in Im1.dom ==> domValid(domMinus(Im1.inf[n1], In1.out[n1])) with {
    if (n1 in Im1.dom) {
      pure assert forall k: K :: domMinus(Im1.inf[n1], In1.out[n1])[k] >= 0 with {
        pure assert Im1.inf[n1][k] - In1.out[n1][k] >= 0;
      }
    }
  }

  pure assert forall n1: Node :: n1 in In1.dom ==> domValid(domMinus(In1.inf[n1], Im1.out[n1])) with {
    if (n1 in In1.dom) {
      pure assert forall k: K :: domMinus(In1.inf[n1], Im1.out[n1])[k] >= 0 with {
        expand_inf2(n1, k, Ip, In);
        pure assert In1.inf[n1][k] - Im1.out[n1][k] >= 0;
      }
    }
  }
  }

  ghost var Inm1 := intComp(Im1, In1);

  pure assert intComposable(Ip1, intComp(Im1, In1)) with {
  lemma_int_comp_unfold(Im1, In1);
  pure assert forall n1: Node, k1: K ::
    n1 in Ip1.dom ==> Ip1.inf[n1][k1] == domPlus(Inm1.out[n1], domMinus(Ip1.inf[n1], Inm1.out[n1]))[k1] with {
      if (n1 == p) {
        expand_out(n1, k1, Im1, In1);
        pure assert Ip1.inf[n1][k1] == Inm1.out[n1][k1] + (Ip1.inf[n1][k1] - Inm1.out[n1][k1]);
        pure assert Ip1.inf[n1][k1] == Inm1.out[n1][k1] + domMinus(Ip1.inf[n1], Inm1.out[n1])[k1];
      }
  }
    
  pure assert forall n1: Node, k1: K ::
    n1 in Inm1.dom ==> Inm1.inf[n1][k1] == domPlus(Ip1.out[n1], domMinus(Inm1.inf[n1], Ip1.out[n1]))[k1] with {
      if (n1 in Inm1.dom) {
        expand_inf2(n1, k1, Im1, In1);
        expand_inf1(n1, k1, Im1, In1);
        pure assert Inm1.inf[n1][k1] == Ip1.out[n1][k1] + (Inm1.inf[n1][k1] - Ip1.out[n1][k1]);
        pure assert Inm1.inf[n1][k1] == Ip1.out[n1][k1] + domMinus(Inm1.inf[n1], Ip1.out[n1])[k1];
      }
  }

  pure assert forall n1: Node :: n1 in Ip1.dom ==> domValid(domMinus(Ip1.inf[n1], Inm1.out[n1])) with {
    if (n1 in Ip1.dom) {
      pure assert forall k: K :: domMinus(Ip1.inf[n1], Inm1.out[n1])[k] >= 0 with {
        expand_out(n1, k, Im1, In1);
        pure assert Ip1.inf[n1][k] - Inm1.out[n1][k] >= 0;
      }
    }
  }

  pure assert forall n1: Node :: n1 in Inm1.dom ==> domValid(domMinus(Inm1.inf[n1], Ip1.out[n1])) with {
    if (n1 in Inm1.dom) {
      pure assert forall k: K :: domMinus(Inm1.inf[n1], Ip1.out[n1])[k] >= 0 with {
        expand_inf1(n1, k, Im1, In1);
        expand_inf2(n1, k, Im1, In1);
        pure assert Inm1.inf[n1][k] - Ip1.out[n1][k] >= 0;
      }
    }
  }
  }

  Ipnm1 := intComp(Ip1, intComp(Im1, In1));

  pure assert intLeq(Ipn, Ipnm1) && Ipnm1.inf[m] == domZero with {
    pure assert forall n1: Node, k1: K :: n1 in Ipn.dom ==> Ipn.inf[n1][k1] == Ipnm1.inf[n1][k1]
      && Ipnm1.inf[m][k1] == 0
      with {
        expand_inf1(n1, k1, Ip, In);
        expand_inf2(n1, k1, Ip, In);
        expand_inf1(n1, k1, Ip1, Inm1);
        expand_inf2(n1, k1, Ip1, Inm1);

        expand_inf2(n1, k1, Im1, In1);
          
        expand_out(p, k1, Im1, In1);
        expand_inf2(m, k1, Ip1, Inm1);
        expand_inf2(m, k1, Im1, In1);
        expand_inf1(m, k1, Im1, In1);
    }

    pure assert (forall n1: Node, k1: K :: n1 !in Ipn.dom ==> Ipn.out[n1][k1] == Ipnm1.out[n1][k1]) with {
      expand_out(n1, k1, Ip, In);
      expand_out(n1, k1, Im1, In1);
      expand_out(n1, k1, Ip1, Inm1);
    }
  }
  
  Cpnm1 := contents(n) ++ contents(m) ++ contents(p);

  pure assert "test1" old(keyset(Ip, p)) == keyset(Ip1, p) with {
    pure assert "test" forall k: K :: Ip.out[n][k] == Ip1.out[m][k];
    pure assert "test5" forall k: K :: old(in_keyset(k, Ip, p)) == in_keyset(k, Ip1, p);

    pure assert "test6" forall k: K :: old(k in keyset(Ip, p)) == (k in keyset(Ip1, p)) with {
      if (k in old(keyset(Ip, p))) {        
        pure assert "test7" old(in_inset(k, Ip, p));
      } 
    }

    
  } // OK

  pure assert "test3"
    old(keyset(In, n)) == keyset(In1, n) ++ keyset(Im1, m)
    && Disjoint(keyset(In1, n), keyset(Im1, m))
    with {
      pure assert "test2" forall k1: K :: old(k1 in keyset(In, n)) ==> (k1 in keyset(In1, n) || k1 in keyset(Im1, m)) with {
      pure assert "test2" old(k1 in keyset(In, n)) ==> old(in_inset(k1, In, n));
    } // OK
    pure assert "test4" forall k1: K :: k1 in keyset(In1, n) ==> old(k1 in keyset(In, n)) with {
      pure assert "test4" k1 in keyset(In1, n) ==> in_inset(k1, In1, n);
    }
    pure assert "test12" forall k1: K :: (k1 in keyset(Im1, m) ==> old(k1 in keyset(In, n)))
      && (k1 in keyset(Im1, m) ==> k1 !in keyset(In1, n))
      && (k1 in keyset(In1, n) ==> k1 !in keyset(Im1, m))
      with {
      if (in_keyset(k1, Im1, m)) {
        lemma_int_comp_unfold(Ip, In);
        pure assert "test10" In.inf[n] == domPlus(Ipn.inf[n], Ip.out[n]);
        pure assert "test10" In.inf[n][k1] == Ipn.inf[n][k1] + Ip.out[n][k1];
      }
    }
  }
}

