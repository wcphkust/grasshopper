/** Flow domain for multisets over some element type K */

include "flows.spl"
include "multipair-ccm.spl"

type FlowDom = MultiPair

lemma domMinus_inv(m1: MultiPair, m2: MultiPair)
  ensures m1 == domPlus(m2, domMinus(m1, m2))
{
  pure assert forall k: K :: m1.ks[k] == domPlus(m2, domMinus(m1, m2)).ks[k] with {
    pure assert m1.ks[k] == m2.ks[k] + (m1.ks[k] - m2.ks[k]);
    pure assert m1.ks[k] == m2.ks[k] + domMinus(m1, m2).ks[k];
  }
  pure assert forall k: K :: m1.ir[k] == domPlus(m2, domMinus(m1, m2)).ir[k] with {
    pure assert m1.ir[k] == m2.ir[k] + (m1.ir[k] - m2.ir[k]);
    pure assert m1.ir[k] == m2.ir[k] + domMinus(m1, m2).ir[k];
  }
  
}

/** Lemmas needed by Coq */

/* TODO: update once Iris proofs are stable */
/*lemma flowint_step(I1: Interface, I2: Interface, I: Interface, x: Node, y: Node, k: K)
  requires I == intComp(I1, I2) && intValid(I)
  requires I.out[y] == domZero
  requires I1.out[y][k] >= 1
  ensures y in I2.dom
{
  pure assert I1.out[y] != domZero;
  lemma_int_comp_unfold(I1, I2);
  if (y !in I.dom) {
    pure assert I.out[y] == domPlus(I1.out[y], I2.out[y]);
    pure assert I.out[y].pi1[k] == I1.out[y].pi1[k] + I2.out[y].pi1[k];
  }
   }*/