/** B+ tree implementation of the give-up template for linearizable dictionaries. */

options "-simplearrays -propreads"

include "give-up.spl"
include "array_util.spl"

/** Definition of a node */

struct Node {
  var len: Int;
  var rangeLb: K;
  var rangeUb: K;
  var keys: Array<K>;
  var ptrs: Array<Node>;
}

var B: Int

/** {Spec} Definition of heap representation, hrep */

axiom B > 1

define hrepSpatial(x) {
  acc(x) &*& acc(x.keys) &*& acc(x.ptrs)
}

// The definition of the implementation-specific node predicate assumed by Iris
define node(x, I, C) {
  hrepSpatial(x) &*& I.dom == {x} // TODO where to put this?
    && 0 <= x.len && x.len < 2*B && x.keys.length == 2*B && x.ptrs.length == 2*B
    // The keys are within the range
    && (x.len != 0 ==> le(x.rangeLb, x.keys[0]) && lt(x.keys[x.len-1], x.rangeUb))
    // The range defines the inset
    && (forall k: K :: I.inf[x][k] == 1 && le(x.rangeLb, k) && lt(k, x.rangeUb)
    || I.inf[x][k] == 0 && (lt(k, x.rangeLb) || le(x.rangeUb, k)))
    // Keys are sorted
    && (forall i: Int, j: Int :: 0 <= i < j < x.len ==> lt(x.keys[i], x.keys[j]) @(noinst i) @(noinst j))
    && (x.ptrs[0] == null  // Leaf
       && (forall n: Node, n1: Node :: I.out[n1] == domZero)
       && C == set_of_map(x.keys.map, 0, x.len)
     || x.ptrs[0] != null  // Internal
       && C == {}
       && (forall i: Int :: 0 <= i <= x.len ==> x != x.ptrs[i])
         && (forall i: Int, j: Int :: 0 <= i < j <= x.len ==> x.ptrs[i] != x.ptrs[j] @(noinst i) @(noinst j))
       && (forall i: Int :: 0 <= i <= x.len ==> x.ptrs[i] != null)
       && (forall i: Int, k: K :: 0 <= i <= x.len ==>
          (I.out[x.ptrs[i]][k] == 1
          && ((0 < i ==> le(x.keys[i-1], k)) && (i < x.len ==> lt(k, x.keys[i])))
           || I.out[x.ptrs[i]][k] == 0
           && !((i <= 0 || le(x.keys[i-1], k)) && (i >= x.len || lt(k, x.keys[i]))))
          @(matching x.ptrs[i] yields x.keys[i - 1])
          @(matching x.ptrs[i] yields x.keys[i]))
          //       && (forall i: Int :: 0 <= i <= x.len ==> I.fm[x][x.ptrs[i]].pc == 1)
       )
}


/** {Spec} Implemetation-specific lemmas needed by Iris */

lemma node_sep_star(n: Node, I_n: Interface, I_np: Interface, C: Set<K>, Cp: Set<K>)
  requires node(n, I_n, C) &*& node(n, I_np, Cp)
  ensures false
{
  
}

/** {Spec} Lemmas for proofs below */

lemma keyset_implies_leaf(x: Node, Ix: Interface, k: K, i: Int, implicit ghost C: Set<K>)
  requires node(x, Ix, C) &*& intValid(Ix)
  requires Ix.inf[x][k] == 1 && (forall y: Node :: Ix.out[y][k] == 0)
  requires (i <= 0 || le(x.keys[i-1], k)) && 0 <= i <= x.len
  ensures node(x, Ix, C)
  ensures x.ptrs[0] == null  // x is a leaf
{
  if (x.ptrs[0] != null) {
    if (i < x.len) {
      if (lt(k, x.keys[i])) {
        pure assert Ix.out[x.ptrs[i]][k] == 1;
      } else {
        keyset_implies_leaf(x, Ix, k, i + 1);
      }
    } else {
      pure assert Ix.out[x.ptrs[i]][k] == 1;
    }
  }
}

/** Begin programs */

/* Initialize root node */
procedure init() returns (x: Node, I: Interface, implicit ghost C: Set<K>)
  ensures node(x, I, C) &*& intValid(I) &*& C == {}
{
  x := new Node;
  x.keys := new Array<K>(2*B);
  x.ptrs := new Array<Node>(2*B);
  arr_init_node(x.ptrs, 2*B, null);
  x.len := 0;
  x.rangeLb := bot;
  x.rangeUb := top;
  
  var xkc := { k: K :: le(bot, k) && lt(k, top) ? 1 : 0 };
  var xfm := { n1: Node :: domZero };
  I := int({ n: Node :: n == x ? xkc : domZero },
            xfm, {x});
  pure assert intValid(I);
}


/* inRange */
procedure inRange(x: Node, k: K, Ix: Interface, implicit ghost C: Set<K>)
  returns (res: Bool)
  requires node(x, Ix, C)
  ensures node(x, Ix, C) &*& (res ==> Ix.inf[x][k] >= 1)
{
  return le(x.rangeLb, k) && lt(k, x.rangeUb);
}

/* findNext */
procedure findNext(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>)
  returns (n: Node)
  requires node(x, Ix, C) &*& intValid(Ix)
  ensures node(x, Ix, C)
  ensures n != null ==> Ix.out[n][k] >= 1
  ensures n == null ==> (forall y: Node :: Ix.out[y][k] == 0)
{
  if (x.ptrs[0] == null) {  // Leaf node
    return null;
  }
  
  var found, i := arr_find(x.keys, x.len, k);

  if (i < x.len && k == x.keys[i]) {
    i := i + 1;
  }
  
  n := x.ptrs[i];
  // return n;
}


/* search */
procedure search(x: Node, k: K, ghost Ix: Interface)
  returns (succ: Bool, res: Bool, implicit ghost C: Set<K>)
  requires node(x, Ix, C) &*& intValid(Ix)
  requires Ix.inf[x][k] == 1 && (forall y: Node :: Ix.out[y][k] == 0)
  ensures node(x, Ix, C)
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (res == k in C)
{
  keyset_implies_leaf(x, Ix, k, 0);

  var idx: Int;
  res, idx := arr_find(x.keys, x.len, k);

  return true, res;
}

/* insert */
procedure insert(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>)
  returns (succ: Bool, res: Bool, implicit ghost C1: Set<K>)
  requires node(x, Ix, C) &*& intValid(Ix)
  requires Ix.inf[x][k] == 1 && (forall y: Node :: Ix.out[y][k] == 0)
  ensures node(x, Ix, C1)
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (C1 == C ++ {k} && (res == k !in C))
  ensures !succ ==> C1 == C
{
  keyset_implies_leaf(x, Ix, k, 0);

  if (x.len < 2*B - 1) {
  
    ghost var m := x.keys.map;
    var old_len := x.len;
    
    var idx, new_len := arr_insert(x.keys, k, x.len);

    map_insert_content_set(m, x.keys.map, idx, k, x.len, new_len);

    x.len := new_len;

    return true, new_len != old_len; 
  } else {
    return false, false;
  }
}


/* delete */
procedure delete(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>)
  returns (succ: Bool, res: Bool, implicit ghost C1: Set<K>)
  requires node(x, Ix, C) &*& intValid(Ix)
  requires Ix.inf[x][k] == 1 && (forall y: Node :: Ix.out[y][k] == 0)
  ensures node(x, Ix, C1)
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (C1 == C -- {k} && (res == k in C))
  ensures !succ ==> C1 == C
{
  keyset_implies_leaf(x, Ix, k, 0);

  ghost var m := x.keys.map;
  var old_len := x.len;
  
  var new_len, idx := arr_delete(x.keys, k, x.len);

  map_delete_content_set(m, x.keys.map, x.len, new_len, idx, k);

  x.len := new_len;

  return true, new_len != old_len;
}

