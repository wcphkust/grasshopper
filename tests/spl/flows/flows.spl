/* -- Lemma library for flows. Independent of Flow domain. -- */

options "-simplearrays -propreads -abspreds -stratify"

// The type of nodes
type Node

// The type of the flow domain
type FlowDom
  
  
// Flow Interfaces
datatype Interface =
  int(inf: Map<Node, FlowDom>,
      out: Map<Node, FlowDom>,
      dom: Set<Node>)
  | intUndef; // For when compositions don't exist

/* The zero flow */
function zeroFlow() returns (f: Map<Node, FlowDom>) {
  { n: Node :: domZero }
}
  
/* The empty flow interface */
function intEmp() returns (I: Interface) {
  int(zeroFlow, zeroFlow, {})
}
  
// Interface composition
pure function intComp(I1: Interface, I2: Interface) returns (I: Interface)
/*{
  I1 == intUndef || I2 == intUndef || !(Disjoint(I1.dom, I2.dom))
    || (exists n in I1.dom :: I1.inf[n] != domPlus(I2.out[n], domMinus(I1.inf[n], I2.out[n])))
    || (exists n in I2.dom :: I2.inf[n] != domPlus(I1.out[n], domMinus(I2.inf[n], I1.out[n]))) ?
    intUndef :
    int({n: Node :: n in I1.dom ? domMinus(I1.inf[n], I2.out[n]) :
         (n in I2.dom ? domMinus(I2.inf[n], I1.out[n]) :
         domZero)},
      {n: Node :: n !in I1.dom && n !in I2.dom ? domPlus(I1.out[n], I2.out[n]) : domZero},
      I1.dom ++ I2.dom)
}*/

axiom forall I: Interface, I1: Interface, I2: Interface :: I == intComp(I1, I2) && I != intUndef ==> I.dom == I1.dom ++ I2.dom

axiom forall I: Interface, I1: Interface, I2: Interface :: I == intComp(I1, I2) && I != intUndef ==> Disjoint(I1.dom, I2.dom)

// Contextually extension of interfaces
pure predicate intLeq(I1: Interface, I2: Interface) {
  I1 != intUndef && I2 != intUndef &&
  I1.dom <= I2.dom
  && (forall x: Node :: x in I1.dom ==> I1.inf[x] == I2.inf[x]
     @(matching x yields I1.inf[x]) @(matching x yields I2.inf[x]))
  && (forall x: Node :: x !in I1.dom ==> I1.out[x] == I2.out[x]
     @(matching x yields I1.out[x]) @(matching x yields I2.out[x]))
}

// Associativity, commutativity, cancellativity of intComp
axiom forall I1: Interface, I2: Interface, I3: Interface ::
  intComp(I1, intComp(I2, I3)) == intComp(intComp(I1, I2), I3)
axiom forall I1: Interface, I2: Interface ::
  intComp(I1, I2) == intComp(I2, I1) @(matching intComp(I1, I2) yields intComp(I2, I1))

// Composition of undef with anything is undef
axiom forall I1: Interface, I2: Interface ::
  intComp(I1, I2) != intUndef ==> (I1 != intUndef && I2 != intUndef);

// The empty interface is the unit of interface composition
axiom forall I: Interface :: intComp(I, intEmp) == I
    
// Unfolds definition of interface composition
lemma lemma_int_comp_unfold(I1: Interface, I2: Interface)
  requires intComp(I1, I2) != intUndef
  ensures intComp(I1, I2).dom == I1.dom ++ I2.dom
  ensures Disjoint(I1.dom, I2.dom)
  ensures I1 != intUndef
  ensures I2 != intUndef
  ensures forall n: Node :: n in I1.dom ==> I1.inf[n] == domPlus(intComp(I1, I2).inf[n], I2.out[n])
  ensures forall n: Node :: n in I2.dom ==> I2.inf[n] == domPlus(intComp(I1, I2).inf[n], I1.out[n])
  ensures forall n: Node :: n !in intComp(I1, I2).dom ==> intComp(I1, I2).out[n] = domPlus(I1.out[n], I2.out[n])

lemma lemma_int_comp_fold(I1: Interface, I2: Interface)
  requires I1 != intUndef && I2 != intUndef
  requires Disjoint(I1.dom, I2.dom)
  requires forall n in I1.dom :: I1.inf[n] == domPlus(I2.out[n], domMinus(I1.inf[n], I2.out[n]))
  requires forall n in I2.dom :: I2.inf[n] == domPlus(I1.out[n], domMinus(I2.inf[n], I1.out[n]))
  ensures intComp(I1, I2) != intUndef
   