/** B+ tree implementation of the link template for linearizable dictionaries. */

options "-abspreds -simplearrays -propreads -stratify"

include "multipair-flows.spl"
include "array_util.spl"

function keyspace() returns (m: Multiset)
{
  { k: K :: 1 }
}

/** Definition of a node */

struct Node {
  var len: Int;
  var keys: Array<K>;
  var ptrs: Array<Node>;
  var next: Node;
  ghost var indices: Map<Node, Int>;
}

/** Definition of heap representation, hrep */

// Width of the B-trees
const B: Int
axiom B > 1

// Access permissions associated with a B-link tree node x
predicate hrepSpatial(x: Node) {
  acc(x) &*& acc(x.keys) &*& acc(x.ptrs) &*& x.keys.length == 2*B && x.ptrs.length == 2*B
}

// k in edgeset(x, u) for child u
define ks_child(x, u, k)
{
  (x.indices[u] == 0 || !lt(k, x.keys.map[x.indices[u] - 1])) &&
    (x.indices[u] == x.len && x.next == null && lt(k, top) || lt(k, x.keys.map[x.indices[u]]))
}

// k in edgest(x, x.next)
define map_next(x, k)
{
  x.next != null && !lt(k, x.keys[x.len]) && lt(k, top)
}

// The flow map of a B-link tree node x
function edgeFn(x: Node, inflow: Map<Node, FlowDom>)
  returns (res: Map<Node, FlowDom>)
  requires hrepSpatial(x)
{
  { n: Node ::
    0 <= x.indices[n] <= x.len ? pair({ k: K :: ks_child(x, n, k) ? inflow[x].ks[k] : 0}, mapZero) :
    (n == x.next ? pair({ k: K :: map_next(x, k) ? inflow[x].ks[k] : 0}, { k: K :: map_next(x, k) ? inflow[x].ir[k] : 0}) : domZero)
  }
}

// Show that edgeFn is valid if inflow is valid
lemma edgeFn_valid(x: Node, inflow: Map<Node, FlowDom>)
  requires forall n: Node :: domValid(inflow[n])
  ensures forall n: Node :: domValid(edgeFn(x, inflow)[n])
{
  pure assert forall n: Node, k: K :: edgeFn(x, inflow)[n].ks[k] >= 0 with {
    pure assert 0 <= x.indices[n] <= x.len && ks_child(x, n, k) ==> edgeFn(x, inflow)[n].ks[k] == inflow[x].ks[k];
  }
  pure assert forall n: Node, k: K :: edgeFn(x, inflow)[n].ir[k] >= 0 with {
    if (0 <= x.indices[n] <= x.len) {
      pure assert edgeFn(x, inflow)[n].ir[k] == 0;
    } else {
      pure assert n == x.next && map_next(x, k) ==> edgeFn(x, inflow)[n].ir[k] == inflow[x].ir[k];
    }
  }
}

// The outset of a B-link tree node x
function outset(x: Node)
  returns (res: Set<K>)
  requires acc(x)
{
  x.ptrs[0] == null ?
  { k: K :: x.next != null && !lt(k, x.keys[x.len]) && lt(k, top) } :
  { k: K :: lt(k, top) }
}

/* Is this still needed? 
// Show that outset is defined correctly - part 1
lemma outset_correct1(x: Node, Ix: Interface, k: K, y: Node, C: Set<K>)
  requires hrep(x, Ix, C) &*& intValid(Ix)
  requires Ix.out[y].ks[k] >= 1
  pure ensures k in outset(x)
{
}

// Show that outset is defined correctly - part 2
lemma outset_correct2(x: Node, Ix: Interface, k: K, C: Set<K>)
  returns (y: Node)
  requires hrep(x, Ix, C) &*& intValid(Ix)
  requires k in outset(x)
  pure ensures Ix.out[y].ks[k] >= 1
{
  pure assert edgeFn(x, Ix.inf)[y] == Ix.out[y];
  if (x.ptrs[0] == null) { 
    y := x.next;
    return y;
  } else {
    var i: Int := map_find(x.keys.map, 0, x.len, k);
    
    if (i < x.len && k == x.keys.map[i]) {  // map_find finds upper bound, we want lower
      i := i + 1;
    }

    if (i == x.len && x.next != null) {
      if (lt(k, x.keys.map[i])) {
        y := x.ptrs[i];
        return y;
      } else {
        y := x.next;
        return y;
      }
    } else {
      y := x.ptrs[i];
      return y;
    }
    return y;
  }
}
 */

// The contents of a node
function contents(x: Node) returns (C: Set<K>)
  requires hrepSpatial(x)
  requires 0 <= x.len
{
  x.ptrs[0] == null ? set_of_map(x.keys.map, 0, x.len) : {}
}

// The interface of a node
function interface(x: Node, inflow: Map<Node, FlowDom>)
  returns (res: Interface)
  requires hrepSpatial(x)
{
  int(inflow, edgeFn(x, inflow), {x})
}

// These are the conditions on the fields of x for abstraction to graph to work
define heapGood(x)
{
  x.next != x && 0 <= x.len < 2*B && (x.next == null ==> x.keys[x.len] == top)
  // Keys are sorted (TODO: internal vs. child?)
  && (forall i: Int, j: Int :: 0 <= i < j <= x.len ==> lt(x.keys[i], x.keys[j]) @(noinst i) @(noinst j))
  // All outgoing pointers are distinct
  && (forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len
       ==> x != x.ptrs[i])
  && (forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len
       ==> x.ptrs[i] != x.next)
  && (forall i: Int, j: Int :: x.ptrs[0] != null && 0 <= i < j <= x.len
       ==> x.ptrs[i] != x.ptrs[j])
  // Indices of outgoing pointers are stored in x.indices
  && (forall n: Node :: 0 <= x.indices[n] <= x.len ==> x.ptrs.map[x.indices[n]] == n)
  && (forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len ==> x.indices[x.ptrs.map[i]] == i)
  && (forall n: Node :: -1 <= x.indices[n] <= x.len)
  && (x.ptrs[0] == null ==> (forall n: Node :: x.indices[n] == -1 @(noinst n)))
  && x.indices[x.next] == -1  // TODO these two might be redundant
  && x.indices[x] == -1
  // Internal nodes don't point to null
  && (forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len ==> x.ptrs[i] != null)
}

// Invariant of a B-link tree node x with flow interface I
define hrep(x, I, C) {
  hrepSpatial(x) &*& heapGood(x) &*& I == interface(x, I.inf) &*& C == contents(x)
}


// The good condition
define searchStrInv(x, I, C) {
    // Contents subsetof keyset
    (forall k1: K :: k1 in C ==> I.inf[x].ks[k1] >= 1)
    && (forall k1: K, y: Node :: k1 !in C || I.out[y].ks[k1] == 0)
    // Edgesets are disjoint
    && (forall k1: K, y: Node, z: Node :: y == z
       || I.out[y].ks[k1] == 0 || I.out[z].ks[k1] == 0)
    // Inreach keyset subsetof inset
    && (forall k1: K :: I.inf[x].ir[k1] >= 1 && k1 !in outset(x)
       ==> I.inf[x].ks[k1] >= 1)
    && (forall k1: K :: I.inf[x].ir[k1] >= 1 && I.inf[x].ks[k1] == 0 ==> !lt(k1, x.keys[x.len]))
    // TODO: If k âˆˆ inreach, then inreach edgeset is same as normal edgeset (for step)
    //&& (forall k1: K, y: Node :: I.inf[x].ir[k1] >= 1 && I.inf[x].ks[k1] <= 0
    //   && I.out[y].ks[k1] >= 1 ==> I.out[y].ir[k1] >= 1)
    // The node label stores the actual inreach
    //&& I.na.inr.inrdom == {x}
    //&& (forall k: K :: (k in I.na.inr.inrfn[x]) == (I.inf[x].ks[k] >= 1 || I.inf[x].ir[k] >= 1))
}

define node(x, I, C) {
  hrep(x, I, C) &*& searchStrInv(x, I, C)
}

lemma node_implies_nodeint(n: Node, I: Interface, C: Set<K>)
  requires node(n, I, C)
  pure ensures nodeint(n, I, C)
{
  pure assert (forall k1: K :: in_inreach(k1, I, n) && !(in_outset(k1, I, n)) ==> in_inset(k1, I, n)) with {
    if (in_inreach(k1, I, n) && !(in_outset(k1, I, n))) {
      assume false;
    }
  }  
}

// Show that if query key k is in the keyset of node x than x must be a leaf.
lemma keyset_implies_leaf(x: Node, Ix: Interface, k: K, i: Int, implicit ghost C: Set<K>)
  requires hrep(x, Ix, C) &*& intValid(Ix)
  requires lt(k, top)
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.out[y].ks[k] == 0)
  requires (i <= 0 || !lt(k, x.keys[i-1])) && 0 <= i <= x.len
  ensures hrep(x, Ix, C)
  ensures x.ptrs[0] == null  // x is a leaf
{
  if (x.ptrs[0] != null && i < x.len && !lt(k, x.keys[i])) {
    keyset_implies_leaf(x, Ix, k, i + 1);
    return;
  } else {
    if (x.ptrs[0] != null && lt(k, x.keys[i])) {
      pure assert Ix.out[x.ptrs[i]].ks[k] == 0;
    } 
    return;
  }
}

lemma lemma_edgesets_disjoint(x: Node, Ix: Interface, inflow: Map<Node, FlowDom>)
  requires hrepSpatial(x)
  requires heapGood(x)
  requires Ix = interface(x, inflow) &*& intValid(Ix)
  pure ensures forall k: K, y: Node, z: Node :: Ix.out[y].ks[k] != 0 ==> y == z || Ix.out[z].ks[k] == 0 
{
  pure assert forall k: K, y: Node, z: Node :: Ix.out[y].ks[k] != 0 ==> y == z || Ix.out[z].ks[k] == 0 with {
    if (y != z && Ix.out[y].ks[k] != 0) {
      pure assert Ix.out == edgeFn(x, Ix.inf);
      if (Ix.out[z].ks[k] > 0) {
        if (x.next == y || x.next == z) {
          ghost var u: Node;
          if (x.next == y) {
            u := z;
          } else {
            u := y;
          }
        } else if (0 <= x.indices[y] <= x.len && 0 <= x.indices[z] <= x.len) {
          pure assert x.indices[z] == x.indices[y] ==> x.ptrs[x.indices[z]] == y;
        }
      }
    }
  }
}

/*
/** Lemmas needed by Coq */

lemma flowint_inset_step(I: Interface, x: Node, Ix: Interface, y: Node, Iy: Interface, k: K)
  requires Ix.FP == {x} && Iy.FP == {y} && I == intComp(Ix, Iy) && intValid(I)
  requires Ix.inf[x].ks[k] >= 1 && Ix.fm[x][y].ks[k] >= 1 || Ix.inf[x].ir[k] >= 1 && Ix.fm[x][y].ir[k] >= 1
  ensures Iy.inf[y].ks[k] >= 1 || Iy.inf[y].ir[k] >= 1
{
  pure assert true
    && domMult(Ix.inf[x], Ix.fm[x][y]).ks[k] == Ix.inf[x].ks[k] * Ix.fm[x][y].ks[k]
    || domMult(Ix.inf[x], Ix.fm[x][y]).ir[k] == Ix.inf[x].ir[k] * Ix.fm[x][y].ir[k];
  pure assert !domEq(domMult(Ix.inf[x], Ix.fm[x][y]), domZero());
  lemma_acyclic_2(x, Ix, y, Iy);
  lemma_int_comp_unfold(x, Ix, y, Iy, I);
  lemma_int_valid_unfold_I(I);
}

lemma flowint_proj(I: Interface, x: Node, Ix: Interface, Iy: Interface, k: K)
  requires I == intComp(Ix, Iy) && intValid(I) && x in Ix.FP
  requires I.inf[x].ks[k] >= 1
  ensures Ix.inf[x].ks[k] >= 1
{
  lemma_proj(x, Ix, Iy, I);
}

lemma flowint_cont(I: Interface, Im: Interface, I1: Interface, m: Node)
  requires I1 == intComp(I, Im) && intValid(I1) && Im == newInt(m)
  ensures I.na.contents == I1.na.contents
{}

lemma flowint_step(I1: Interface, I2: Interface, I: Interface, x: Node, y: Node, k: K)
  requires I == intComp(I1, I2) && intValid(I) && x in I1.FP
  requires forall n: Node, n1: Node :: domEq(I.fm[n][n1], domZero)
  requires I1.fm[x][y].ks[k] >= 1 || I1.fm[x][y].ir[k] >= 1 
  ensures y in I2.FP
{
  lemma_int_valid_unfold_I(I1);
  lemma_step(I1, I2, I, x, y);
}

*/

/** Begin programs */

define emptyInt(x, Ix) {
  Ix.dom == {x} && Ix.inf[x] == domZero
  && (forall y: Node :: Ix.out[y] == domZero)
  //&& Ix.na == nd({}, inrfnC({n: Node :: {}}, {x}))
}

/** Initialize a new root node */
procedure init() returns (x: Node, I: Interface)
  ensures node(x, I, Set<K>()) &*& intValid(I)
{
  x := new Node;
  x.keys := new Array<K>(2*B);
  x.keys[0] := top;
  x.ptrs := new Array<Node>(2*B);
  x.ptrs[0] := null;
  x.len := 0;
  x.next := null;
  x.indices := { n: Node :: -1 };

  ghost var x_inflow := { n: Node :: n == x ? pair(keyspace, keyspace) : domZero };
  
  I := interface(x, x_inflow);
}

/** findNext */
procedure findNext(x: Node, k: K, Ix: Interface, implicit ghost C: Set<K>)
  returns (n: Node)
  requires lt(k, top)
  requires node(x, Ix, C) &*& intValid(Ix)
  requires Ix.inf[x].ks[k] > 0 || Ix.inf[x].ir[k] > 0
  ensures node(x, Ix, C)
  ensures n != null ==> Ix.out[n].ks[k] > 0 || Ix.out[n].ir[k] > 0
  ensures n == null ==> (forall y: Node :: Ix.out[y].ks[k] == 0 && Ix.out[y].ir[k] == 0)
{
  if (x.ptrs[0] == null) {  // Leaf node
    if (x.next == null) {
      return null;
    }
    if (le(x.keys[x.len], k)) {
      return x.next;
    } else {
      return null;
    }
  }

  var found, i := arr_find(x.keys, x.len, k);

  if (i < x.len && k == x.keys[i]) {  // arr_find finds upper bound, we want lower
    i := i + 1;
  }

  if (i == x.len && x.next != null) {
    if (lt(k, x.keys[i])) {
      n := x.ptrs[i];
      return n;
    } else {
      n := x.next;
      return n;
    }
  } else {
    n := x.ptrs[i];
    return n;
  }
  return n;
}

/** search */
procedure search(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>)
  returns (succ: Bool, res: Bool)
  requires node(x, Ix, C) &*& intValid(Ix)
  requires lt(k, top)
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.out[y].ks[k] == 0)
  ensures hrep(x, Ix, C)
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (res == k in C)
{
  keyset_implies_leaf(x, Ix, k, 0);

  var idx: Int;
  res, idx := arr_find(x.keys, x.len, k);

  return true, res;
}

/** insert */
procedure insert(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>)
  returns (succ: Bool, res: Bool, implicit ghost C1: Set<K>)
  requires node(x, Ix, C) &*& intValid(Ix)
  requires lt(k, top)
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.out[y].ks[k] == 0)
  ensures node(x, Ix, C1)
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (C1 == C ++ {k} && (res == k !in C))
  ensures !succ ==> C1 == C
{
  keyset_implies_leaf(x, Ix, k, 0);

  if (x.len < 2*B - 1) {
    ghost var m0 := x.keys.map;
    if (x.next != null) {
      x.keys[x.len + 1] := x.keys[x.len];
      set_of_map_equal(m0, x.keys.map, 0, 0, x.len);
    } else {
      x.keys[x.len + 1] := top;
      set_of_map_equal(m0, x.keys.map, 0, 0, x.len);
    }
    ghost var m := x.keys.map;
    var old_len := x.len;

    var idx, new_len := arr_insert(x.keys, k, x.len);
    x.len := new_len;

    map_insert_content_set(m, x.keys.map, idx, k, old_len, new_len);

    pure assert Ix == interface(x, Ix.inf) with {
      pure assert forall k1: K, y: Node ::
        Ix.out[y].ks[k1] == edgeFn(x, Ix.inf)[y].ks[k1]
        && Ix.out[y].ir[k1] == edgeFn(x, Ix.inf)[y].ir[k1]
      with {
        pure assert Ix.inf[x].ks[k1] == Ix.inf[x].ks[k1];
        pure assert Ix.inf[x].ir[k1] == Ix.inf[x].ir[k1];
      }
      
    }

    
  return true, old_len != new_len;
  } else {
    return false, false;
  }
}

/** delete */
procedure delete(x: Node, k: K, ghost Ix: Interface, implicit ghost C: Set<K>)
  returns (succ: Bool, res: Bool, implicit ghost C1: Set<K>)
  requires node(x, Ix, C) &*& intValid(Ix)
  requires lt(k, top)
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.out[y].ks[k] == 0)
  ensures node(x, Ix, C1)
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> C1 == C -- {k} && (res == k in C)
  ensures !succ ==> C1 == C
{
  keyset_implies_leaf(x, Ix, k, 0);

  ghost var m := x.keys.map;
  var old_len := x.len;
  
  pure assert set_of_map(x.keys.map, 0, x.len) == C;
  var new_len, idx := arr_delete(x.keys, k, x.len);

  map_delete_content_set(m, x.keys.map, x.len, new_len, idx, k);

  ghost var m1 := x.keys.map;
  x.keys[new_len] := x.keys[x.len];
  set_of_map_equal(m1, x.keys.map, 0, 0, new_len);

  x.len := new_len;
  
  /*pure assert intLeq(Ix, Ix1) with {
    pure assert forall n: Node, k1: K :: n !in Ix1.dom ==> Ix.out[n].ks[k1] == Ix1.out[n].ks[k1] && Ix.out[n].ir[k1] == Ix1.out[n].ir[k1] with {
      if (n !in Ix1.dom) {
        pure assert Ix.inf[x].ks[k1] == Ix1.inf[x].ks[k1];
        pure assert Ix.inf[x].ir[k1] == Ix1.inf[x].ir[k1];
      }
    }      
  }*/
  pure assert Ix == interface(x, Ix.inf) with {
    pure assert forall k1: K, y: Node ::
      Ix.out[y].ks[k1] == edgeFn(x, Ix.inf)[y].ks[k1]
      && Ix.out[y].ir[k1] == edgeFn(x, Ix.inf)[y].ir[k1]
    with {
      pure assert Ix.inf[x].ks[k1] == Ix.inf[x].ks[k1];
      pure assert Ix.inf[x].ir[k1] == Ix.inf[x].ir[k1];
    }
    
  }

  return true, old_len != new_len;
}

/** Half split */

procedure half_split(c: Node, x: Node, Ic: Interface, implicit ghost C: Set<K>)
  returns (Ic1: Interface, Ix1: Interface, Icx1: Interface, Cc: Set<K>, Cx: Set<K>)
  requires node(c, Ic, C) &*& hrepSpatial(x)
  requires intValid(Ic)
  requires c.len == 2 * B - 1
  // GC assumption
  requires c.next != x;
  requires (forall i: Int :: 0 <= i <= c.len ==> x != c.ptrs[i]);
  // Follows from x being allocated freshly
  ensures node(c, Ic1, Cc) &*& node(x, Ix1, Cx)
  ensures intValid(Ic1) && intValid(Ix1)
  ensures intComp(Ic1, Ix1) == Icx1 && intLeq(Ic, Icx1)
  ensures C == Cc ++ Cx
{
  var m := (c.len + 1) / 2;

  /*
  x := new Node;

  x.keys := new Array<K>(2*B);

  x.ptrs := new Array<Node>(2*B);
  
  pure assert (forall i: Int :: c.ptrs[0] != null && 0 <= i <= c.len ==> c.ptrs[i] != null) with {
    if (c.ptrs[0] != null && 0 <= i <= c.len)
      pure assert old(c.ptrs[i]) != null;
  }
  pure assert heapGood(c, C);
  */
  
  pure assert Ic.out[x] == domZero with {
    pure assert forall k: K :: Ic.out[x].ks[k] == 0 with {
      pure assert 0 <= c.indices[x] <= c.len ==> c.ptrs.map[c.indices[x]] == x;
    }
  }
  
  if (c.ptrs[0] == null) {  // Leaf
    arr_copy(c.keys, x.keys, m, 0, m);
    x.ptrs[0] := null;
    x.len := m - 1;
    x.next := c.next;
    c.len := m;
    c.next := x;
    
    ghost var x_inflow_ks := { k: K :: !lt(k, c.keys[c.len]) && lt(k, top) ? Ic.inf[c].ks[k] : 0 };
    ghost var x_inflow_ir := { k: K :: !lt(k, c.keys[c.len]) && lt(k, top) ? Ic.inf[c].ir[k] : 0 };
    ghost var x_inflow := { n: Node :: n == x ? pair(x_inflow_ks, x_inflow_ir) : domZero };
    
    c.indices := { n: Node :: -1 };
    x.indices := { n: Node :: -1 };

    Ic1 := interface(c, Ic.inf);
    Cc := set_of_map(c.keys.map, 0, c.len);
    Ix1 := interface(x, x_inflow);
    Cx := set_of_map(x.keys.map, 0, x.len);

    pure assert C = Cc ++ Cx with {
      set_of_map_split(c.keys.map, 0, m, old(c.len));
      map_copy_content_set(c.keys.map, old(x.keys.map), x.keys.map, m, 0, m, 0, m - 1);
    }

    pure assert intValid(Ic1) with {
      edgeFn_valid(c, Ic.inf);
    }

    pure assert searchStrInv(c, Ic1, Cc) with {
      pure assert forall k1: K, y: Node :: k1 !in Cc || Ic1.out[y].ks[k1] == 0 with {
        if (k1 in Cc && Ic1.out[y].ks[k1] != 0) {
          map_find_in_set(c.keys.map, 0, c.len, k1);
        }
      }
    }

    pure assert intValid(Ix1) with {
      pure assert forall n: Node :: domValid(x_inflow[n]) with {
        pure assert forall k1: K :: x_inflow[n].ks[k1] >= 0 && x_inflow[n].ir[k1] >= 0 with {
          pure assert Ic.inf[c].ks[k1] >= 0;
          pure assert Ic.inf[c].ir[k1] >= 0;
        }
      }
      edgeFn_valid(x, x_inflow);
    }

    pure assert searchStrInv(x, Ix1, Cx) with {
      pure assert forall k1: K :: k1 in Cx ==> Ix1.inf[x].ks[k1] >= 1 with {
        if (k1 in Cx) {
          map_find_in_set(x.keys.map, 0, x.len, k1);
          pure assert Ic.inf[c].ks[k1] >= 1;
        }
      }
      pure assert forall k1: K, y: Node :: k1 !in Cx || Ix1.out[y].ks[k1] == 0 with {
        if (k1 in Cx && Ix1.out[y].ks[k1] != 0) {
          map_find_in_set(x.keys.map, 0, x.len, k1);
        }
      }

      pure assert forall k1: K :: Ix1.inf[x].ir[k1] >= 1 && k1 !in outset(x)
        ==> Ix1.inf[x].ks[k1] >= 1 with {
          if (Ix1.inf[x].ir[k1] >= 1 && k1 !in outset(x)) {
            pure assert Ic.inf[c].ir[k1] >= 1;
            pure assert k1 !in old(outset(c));
            pure assert Ic.inf[c].ks[k1] >= 1;
          }
      }

    }

    pure assert intComposable(Ic1, Ix1) with {
      pure assert (forall n: Node :: n in Ix1.dom ==> Ix1.inf[n] == domPlus(Ic1.out[n], domMinus(Ix1.inf[n], Ic1.out[n]))) with {
        if (n in Ix1.dom) domMinus_inv(Ix1.inf[n], Ic1.out[n]);
      }
      
      pure assert (forall n: Node :: n in Ix1.dom ==> domValid(domMinus(Ix1.inf[n], Ic1.out[n]))) with {
        if (n in Ix1.dom) {
          pure assert forall k: K :: domMinus(Ix1.inf[n], Ic1.out[n]).ks[k] >= 0 with {
            pure assert !lt(k, c.keys[c.len]) && lt(k, top) ==> Ix1.inf[n].ks[k] == Ic.inf[c].ks[k];
            pure assert Ix1.inf[n].ks[k] - Ic1.out[n].ks[k] >= 0;
          }
          pure assert forall k: K :: domMinus(Ix1.inf[n], Ic1.out[n]).ir[k] >= 0 with {
            pure assert !lt(k, c.keys[c.len]) && lt(k, top) ==> Ix1.inf[n].ir[k] == Ic.inf[c].ir[k];
            pure assert Ix1.inf[n].ir[k] - Ic1.out[n].ir[k] >= 0;
          }
        }
      }
        
      pure assert (forall n: Node :: n in Ic1.dom ==> domValid(domMinus(Ic1.inf[n], Ix1.out[n]))) with {
        if (n in Ic1.dom) {
          pure assert forall k: K :: domMinus(Ic1.inf[n], Ix1.out[n]).ks[k] >= 0 with {
            pure assert Ic1.inf[n].ks[k] - Ix1.out[n].ks[k] >= 0;
          }
          pure assert forall k: K :: domMinus(Ic1.inf[n], Ix1.out[n]).ir[k] >= 0 with {
            pure assert Ic1.inf[n].ir[k] - Ix1.out[n].ir[k] >= 0;
          }
        }
      }

      pure assert (forall n: Node :: n in Ic1.dom ==> Ic1.inf[n] == domPlus(Ix1.out[n], domMinus(Ic1.inf[n], Ix1.out[n]))) with {
        if (n in Ic1.dom) domMinus_inv(Ic1.inf[n], Ix1.out[n]);
      }
    }    

    lemma_int_comp_fold(Ic1, Ix1);
    Icx1 := intComp(Ic1, Ix1);

    pure assert intLeq(Ic, Icx1) with {
      lemma_int_comp_unfold(Ic1, Ix1);
      pure assert forall n: Node :: n !in Icx1.dom ==> Ic.out[n] == Icx1.out[n] with {
        if (n !in Icx1.dom) {

          pure assert Icx1.out[n] == domPlus(Ic1.out[n], Ix1.out[n]);
          pure assert forall k: K :: Ic.out[n].ks[k] == Icx1.out[n].ks[k] with {
            pure assert Icx1.out[n].ks[k] == Ic1.out[n].ks[k] + Ix1.out[n].ks[k];

            if (!lt(k, c.keys[c.len]) && lt(k, top) && !lt(k, old(c.keys.map[c.len]))) {
              pure assert Ix1.inf[x].ks[k] == Ic.inf[c].ks[k];
            }
          }
          pure assert forall k: K :: Ic.out[n].ir[k] == Icx1.out[n].ir[k] with {
            pure assert Icx1.out[n].ir[k] == Ic1.out[n].ir[k] + Ix1.out[n].ir[k];

            if (!lt(k, c.keys[c.len]) && lt(k, top) && !lt(k, old(c.keys.map[c.len]))) {
              pure assert Ix1.inf[x].ir[k] == Ic.inf[c].ir[k];
            }
          }
        }
      }

      pure assert forall n: Node :: n in Ic.dom ==> Ic.inf[n] == Icx1.inf[n] with {
        if (n in Ic.dom) {
          pure assert Ic1.inf[n] == domPlus(Icx1.inf[n], Ix1.out[n]);
          domZero_unit(Icx1.inf[n]);
        }
      }
    
    }
   
    return Ic1, Ix1, Icx1, Cc, Cx;
    
  } else {  // Internal node
    
    ghost var clen := c.len;
    ghost var cind := c.indices;

    arr_copy(c.keys, x.keys, m, 0, c.len - m + 1);
    arr_copy_node(c.ptrs, x.ptrs, m, 0, c.len - m + 1);
    x.len := m - 1;
    c.len := m - 1;
    x.next := c.next;
    c.next := x;

    ghost var x_inflow_ks := { k: K :: !lt(k, c.keys[c.len]) && lt(k, top) ? Ic.inf[c].ks[k] : 0};
    ghost var x_inflow_ir := { k: K :: !lt(k, c.keys[c.len]) && lt(k, top) ? Ic.inf[c].ir[k] : 0};
    ghost var x_inflow := { n: Node :: n == x ? pair(x_inflow_ks, x_inflow_ir) : domZero };

    
    c.indices := { n: Node :: n != x && 0 <= cind[n] < m ? cind[n] : -1 };
    x.indices := { n: Node :: n != x && m <= cind[n] <= clen ? cind[n] - m : -1 };

    Ic1 := interface(c, Ic.inf);
    Cc := {};
    Ix1 := interface(x, x_inflow);
    Cx := {};

    pure assert intValid(Ic1) with {
      edgeFn_valid(c, Ic.inf);
    }

    pure assert heapGood(c) with {
      pure assert forall n: Node :: 0 <= c.indices[n] <= c.len ==> c.ptrs.map[c.indices[n]] == n with {
        pure assert 0 <= old(c.indices[n]) <= c.len ==> old(c.ptrs.map[c.indices[n]]) == n;
      }
    }
    
    pure assert searchStrInv(c, Ic1, Cc) with {
      lemma_edgesets_disjoint(c, Ic1, Ic.inf);
    }

    pure assert intValid(Ix1) with {
      pure assert forall n: Node :: domValid(x_inflow[n]) with {
        pure assert forall k1: K :: x_inflow[n].ks[k1] >= 0 && x_inflow[n].ir[k1] >= 0 with {
          pure assert Ic.inf[c].ks[k1] >= 0;
          pure assert Ic.inf[c].ir[k1] >= 0;
        }
      }
      edgeFn_valid(x, x_inflow);
    }

    pure assert heapGood(x) with {
      pure assert forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len ==> x.indices[x.ptrs.map[i]] == i with {
        if (0 <= i <= x.len) {
          ghost var n := old(c.ptrs.map[m + (i - 0)]);
          pure assert x.ptrs.map[i] == n;
          pure assert cind[n] == m + (i - 0);
          pure assert x.indices[n] == cind[n] - m;
        }
      }

      pure assert forall n: Node :: 0 <= x.indices[n] <= x.len ==> x.ptrs.map[x.indices[n]] == n with {
        pure assert m <= old(c.indices[n]) <= old(c.len) ==> old(c.ptrs.map[c.indices[n]]) == n;
        pure assert m <= old(c.indices[n]) <= old(c.len) ==> x.ptrs.map[old(c.indices[n]) - m] == n;
      }
    }
    
    pure assert searchStrInv(x, Ix1, Cx) with {
      pure assert (forall k1: K :: Ix1.inf[x].ir[k1] >= 1 && Ix1.inf[x].ks[k1] == 0 ==> !lt(k1, x.keys[x.len])) with {
        if (Ix1.inf[x].ir[k1] >= 1 && Ix1.inf[x].ks[k1] == 0) {
          pure assert Ic.inf[c].ks[k1] == 0;
          pure assert Ic.inf[c].ir[k1] >= 1;
        }
      }
      
      lemma_edgesets_disjoint(x, Ix1, x_inflow);
    }

    pure assert intComposable(Ic1, Ix1) with {
      pure assert (forall n: Node :: n in Ix1.dom ==> Ix1.inf[n] == domPlus(Ic1.out[n], domMinus(Ix1.inf[n], Ic1.out[n]))) with {
        if (n in Ix1.dom) domMinus_inv(Ix1.inf[n], Ic1.out[n]);
      }
      
      pure assert (forall n: Node :: n in Ix1.dom ==> domValid(domMinus(Ix1.inf[n], Ic1.out[n]))) with {
        if (n in Ix1.dom) {
          pure assert forall k: K :: domMinus(Ix1.inf[n], Ic1.out[n]).ks[k] >= 0 with {
            pure assert !lt(k, c.keys[c.len]) && lt(k, top) ==> Ix1.inf[n].ks[k] == Ic.inf[c].ks[k];
            pure assert Ix1.inf[n].ks[k] - Ic1.out[n].ks[k] >= 0;
          }
          pure assert forall k: K :: domMinus(Ix1.inf[n], Ic1.out[n]).ir[k] >= 0 with {
            pure assert !lt(k, c.keys[c.len]) && lt(k, top) ==> Ix1.inf[n].ir[k] == Ic.inf[c].ir[k];
            pure assert Ix1.inf[n].ir[k] - Ic1.out[n].ir[k] >= 0;
          }
        }
      }
        
      pure assert (forall n: Node :: n in Ic1.dom ==> domValid(domMinus(Ic1.inf[n], Ix1.out[n]))) with {
        if (n in Ic1.dom) {
          pure assert forall k: K :: domMinus(Ic1.inf[n], Ix1.out[n]).ks[k] >= 0 with {
            pure assert Ic1.inf[n].ks[k] - Ix1.out[n].ks[k] >= 0;
          }
          pure assert forall k: K :: domMinus(Ic1.inf[n], Ix1.out[n]).ir[k] >= 0 with {
            pure assert Ic1.inf[n].ir[k] - Ix1.out[n].ir[k] >= 0;
          }
        }
      }

      pure assert (forall n: Node :: n in Ic1.dom ==> Ic1.inf[n] == domPlus(Ix1.out[n], domMinus(Ic1.inf[n], Ix1.out[n]))) with {
        if (n in Ic1.dom) domMinus_inv(Ic1.inf[n], Ix1.out[n]);
      }
    }
    
    lemma_int_comp_fold(Ic1, Ix1);
    Icx1 := intComp(Ic1, Ix1);

    pure assert intLeq(Ic, Icx1) with {
      lemma_int_comp_unfold(Ic1, Ix1);

      pure assert forall n1: Node :: n1 !in Icx1.dom ==> Ic.out[n1] == Icx1.out[n1] with {
        if (n1 !in Icx1.dom) {

          pure assert Icx1.out[n1] == domPlus(Ic1.out[n1], Ix1.out[n1]);

          pure assert forall k: K :: Ic.out[n1].ks[k] == Icx1.out[n1].ks[k] &&
          Ic.out[n1].ir[k] == Icx1.out[n1].ir[k] with {
            pure assert Icx1.out[n1].ks[k] == Ic1.out[n1].ks[k] + Ix1.out[n1].ks[k]
                      && Icx1.out[n1].ir[k] == Ic1.out[n1].ir[k] + Ix1.out[n1].ir[k];

            if (0 <= old(c.indices)[n1] <= old(c.len)) {  // n1 was c's child
              if (old(c.indices)[n1] <= c.len) {  // n1 stayed at c
                pure assert c.indices[n1] == old(c.indices)[n1];
                pure assert ks_child(c, n1, k) ==> Ic1.out[n1].ks[k] == Ic.inf[c].ks[k];
              } else {  // n1 moved to x
                pure assert true
                   && x.ptrs.map[x.indices[n1]] == n1
                   && old(c.ptrs.map)[m + x.indices[n1] - 0] == n1
                   && old(c.keys.map)[m + x.indices[n1] - 0] == x.keys.map[x.indices[n1]]
                   && (x.indices[n1] > 0 ==>
                   old(c.keys.map)[m + (x.indices[n1] - 1) - 0] == x.keys.map[x.indices[n1] - 1]);
                pure assert ks_child(x, n1, k) ==> Ix1.out[n1].ks[k] == Ix1.inf[x].ks[k];
                pure assert old(ks_child(c, n1, k)) ==> Ic.out[n1].ks[k] == Ic.inf[c].ks[k];
              }              
            } else if (n1 == old(c.next)) {  // n1 was c's right sibling
              if (!lt(k, c.keys[c.len]) && lt(k, top) && !lt(k, old(c.keys.map[c.len]))) {
                pure assert true
                  && Ix1.inf[x].ks[k] == Ic.inf[c].ks[k]
                  && Ix1.inf[x].ir[k] == Ic.inf[c].ir[k];
              }
            } else {} // there was no edge from n1 to c
          }
        }
      }

      pure assert forall n: Node :: n in Ic.dom ==> Ic.inf[n] == Icx1.inf[n] with {
        if (n in Ic.dom) {
          pure assert Ic1.inf[n] == domPlus(Icx1.inf[n], Ix1.out[n]);
          domZero_unit(Icx1.inf[n]);
        }
      }
    }
    
    return Ic1, Ix1, Icx1, Cc, Cx;
  }
}

/** Full split */

procedure full_split(p: Node, Ip: Interface, ci: Int, c: Node, Ic: Interface,
  Ipc: Interface, x: Node, implicit ghost Cp: Set<K>, implicit ghost Cc: Set<K>)
  returns (Ip1: Interface, Ic1: Interface)
  requires hrep(p, Ip, Cp) &*& hrep(c, Ic, Cc)
  requires intValid(Ip) && intValid(Ic)
  requires intComp(Ip, Ic) == Ipc && intValid(Ipc)
  requires p.ptrs[0] != null && p.ptrs[ci] == c && 0 <= ci <= p.len && c.next == x
  requires p.len < 2*B - 1 && p.indices[c] == ci
  // Needed to show sortedness, and in range, of p.keys:
  requires ks_child(p, c, c.keys[c.len])
  && (ci == 0 || ci > 0 && lt(p.keys[ci - 1], c.keys[c.len]))
  // Nothing == x:
  requires p.next != x && p.indices[x] == -1
  requires p != x
  requires Ic.out[p] == domZero  // needed for int_comp_unfold

    ensures hrep(p, Ip1, Cp) &*& hrep(c, Ic1, Cc)
  ensures intValid(Ip1) && intValid(Ic1)
  ensures intComp(Ip1, Ic1) == Ipc
{

  var pind := p.indices;  // TODO why doesn't old(p.indices) work?
  var plen := p.len;

  arr_shift(p.keys, ci, ci + 1, p.len + 1 - ci);
  arr_shift_node(p.ptrs, ci + 1, ci + 2, p.len - ci);

  var k := c.keys[c.len];  // everything >= k goes to x
  ghost var c_inflow_ks := { k1: K :: !lt(k1, k) ? Ic.inf[c].ks[k1] - Ip.out[c].ks[k1] : Ic.inf[c].ks[k1] };
  ghost var c_inflow := { n: Node :: n == c ? pair(c_inflow_ks, Ic.inf[c].ir) : domZero };
  
  p.keys[ci] := k;
  p.ptrs[ci + 1] := x;
  p.len := p.len + 1;

  p.indices := { n: Node :: n == x ? ci + 1 : (ci + 1 <= pind[n] <= plen ? pind[n] + 1 : pind[n]) };

  pure assert heapGood(c) with {
    pure assert c.indices == old(c.indices);
    pure assert c.ptrs.map == old(c.ptrs.map);
  }

  pure assert heapGood(p) with {
    pure assert (forall i: Int, j: Int :: 0 <= i < j <= p.len ==> lt(p.keys[i], p.keys[j]) @(noinst i) @(noinst j)) with {  // This works, but takes ages
      pure assert ci < i <= p.len ==> p.keys[i] == old(p.keys[ci + (i - (ci + 1))]);
      pure assert ci < j <= p.len ==> p.keys[j] == old(p.keys[ci + (j - (ci + 1))]);
    }
    pure assert forall n: Node :: 0 <= p.indices[n] <= p.len ==> p.ptrs.map[p.indices[n]] == n with {
      pure assert ci + 1 < old(p.indices[n]) <= old(p.len)
        ==> old(p.ptrs.map[p.indices[n]]) == n;
      pure assert ci + 1 < old(p.indices[n]) <= old(p.len)
        ==> p.ptrs[old(p.indices[n]) + 1] == n;
        if (0 <= p.indices[n] < ci + 1) {
        } else if (p.indices[n] == ci + 1) {
        } else if (ci + 1 < p.indices[n] <= p.len) {
          pure assert old(p.indices[n]) == p.indices[n] - 1;
          pure assert p.ptrs.map[p.indices[n]] == old(p.ptrs.map)[p.indices[n] - 1];
        }
    }
    pure assert forall i: Int :: p.ptrs[0] != null && 0 <= i <= p.len ==> p.indices[p.ptrs.map[i]] == i with {
      pure assert ci + 1 < i <= p.len ==> p.ptrs[i] == old(p.ptrs.map)[(ci + 1) + (i - (ci + 2))];
    }
  }

  /* TODO
  pure assert (forall k: K, y: Node :: Ip.inf[p].ir[k] >= 1 && Ip.inf[p].ks[k] <= 0
    && flowmap(p)[p][y].ks[k] >= 1 ==> flowmap(p)[p][y].ir[k] >= 1) with {
      if (Ip.inf[p].ir[k] >= 1 && Ip.inf[p].ks[k] <= 0
          && flowmap(p)[p][y].ks[k] >= 1) {
        if (ci + 1 < p.indices[y] <= p.len) {
          pure assert old(p.indices[y]) == p.indices[y] - 1;
          pure assert p.ptrs.map[p.indices[y]] == old(p.ptrs.map)[p.indices[y] - 1];
          pure assert 0 <= p.indices[y] - 1 <= old(p.len);
          //pure assert p.ptrs.map[p.indices[y]] == y;
        }
      }
  }
   */
  
  Ip1 := interface(p, Ip.inf);
  Ic1 := interface(c, c_inflow);

  pure assert intValid(Ic1) with {
    pure assert forall n: Node :: domValid(c_inflow[n]) with {
      pure assert forall k1: K :: c_inflow[n].ks[k1] >= 0 && c_inflow[n].ir[k1] >= 0 with {
        pure assert Ipc.inf[c].ks[k1] >= 0;
        pure assert Ipc.inf[c] == domMinus(Ic.inf[c], Ip.out[c]);
        pure assert Ic.inf[c].ks[k1] - Ip.out[c].ks[k1] >= 0;
      }
    }
    edgeFn_valid(c, c_inflow);
  }

  pure assert intValid(Ip1) with {
    edgeFn_valid(p, Ip.inf);
  }
  
  pure assert intComposable(Ip1, Ic1) with {
    pure assert forall n: Node :: n in Ip1.dom ==> Ip1.inf[n] == domPlus(Ic1.out[n], domMinus(Ip1.inf[n], Ic1.out[n])) with {
      if (n in Ip1.dom) {
        pure assert forall k1: K ::
            Ip1.inf[n].ks[k1] == domPlus(Ic1.out[n], domMinus(Ip1.inf[n], Ic1.out[n])).ks[k1]
          && Ip1.inf[n].ir[k1] == domPlus(Ic1.out[n], domMinus(Ip1.inf[n], Ic1.out[n])).ir[k1] with {
            pure assert Ic.out[p].ks[k1] == 0; 
            pure assert Ic.inf[p].ks[k1] >= Ic1.inf[p].ks[k1];
            pure assert edgeFn(c, Ic.inf)[n].ks[k1] != 0 ==> edgeFn(c, Ic.inf)[n].ks[k1] == Ic.inf[c].ks[k1];          
            pure assert old(edgeFn(c, Ic.inf))[n].ks[k1] >= edgeFn(c, Ic1.inf)[n].ks[k1];
            pure assert Ic1.out[p].ks[k1] == 0;
            pure assert Ic1.out[p].ir[k1] == 0;
            pure assert Ip1.inf[n].ks[k1] == Ic1.out[n].ks[k1] + (Ip1.inf[n].ks[k1] - Ic1.out[n].ks[k1]);
            pure assert Ip1.inf[n].ir[k1] == Ic1.out[n].ir[k1] + (Ip1.inf[n].ir[k1] - Ic1.out[n].ir[k1]);
            pure assert Ip1.inf[n].ks[k1] == Ic1.out[n].ks[k1] + domMinus(Ip1.inf[n], Ic1.out[n]).ks[k1];
            pure assert Ip1.inf[n].ir[k1] == Ic1.out[n].ir[k1] + domMinus(Ip1.inf[n], Ic1.out[n]).ir[k1];
            
            pure assert Ip1.inf[n].ks[k1] == domPlus(Ic1.out[n], domMinus(Ip1.inf[n], Ic1.out[n])).ks[k1];
            pure assert Ip1.inf[n].ir[k1] == domPlus(Ic1.out[n], domMinus(Ip1.inf[n], Ic1.out[n])).ir[k1];
        }
      }
      
    }
    pure assert forall n: Node :: n in Ic1.dom ==> Ic1.inf[n] == domPlus(Ip1.out[n], domMinus(Ic1.inf[n], Ip1.out[n])) with {
      pure assert forall n: Node :: n in Ic1.dom ==> Ic1.inf[n] == domPlus(Ip1.out[n], domMinus(Ic1.inf[n], Ip1.out[n])) with {
        if (n in Ic1.dom) {
          pure assert forall k1: K ::
              Ic1.inf[n].ks[k1] == domPlus(Ip1.out[n], domMinus(Ic1.inf[n], Ip1.out[n])).ks[k1]
            && Ic1.inf[n].ir[k1] == domPlus(Ip1.out[n], domMinus(Ic1.inf[n], Ip1.out[n])).ir[k1] with {

            pure assert Ic.inf[n].ks[k1] == domPlus(Ip.out[n], domMinus(Ic.inf[n], Ip.out[n])).ks[k1];
            pure assert Ic.inf[n].ks[k1] == Ip.out[n].ks[k1] + domMinus(Ic.inf[n], Ip.out[n]).ks[k1];
            pure assert Ic.inf[n].ks[k1] == Ip.out[n].ks[k1] + (Ic.inf[n].ks[k1] - Ip.out[n].ks[k1]);
            
            pure assert Ic1.inf[n].ks[k1] == Ip1.out[n].ks[k1] + (Ic1.inf[n].ks[k1] - Ip1.out[n].ks[k1]);
            pure assert Ic1.inf[n].ir[k1] == Ip1.out[n].ir[k1] + (Ic1.inf[n].ir[k1] - Ip1.out[n].ir[k1]);

            pure assert Ic1.inf[n].ks[k1] == Ip1.out[n].ks[k1] + domMinus(Ic1.inf[n], Ip1.out[n]).ks[k1];
            pure assert Ic1.inf[n].ir[k1] == Ip1.out[n].ir[k1] + domMinus(Ic1.inf[n], Ip1.out[n]).ir[k1];
            }
        }
      }
    }
    
    pure assert forall n: Node :: n in Ip1.dom ==> domValid(domMinus(Ip1.inf[n], Ic1.out[n])) with {
      if (n in Ip1.dom) {
        pure assert forall k1: K :: domMinus(Ip1.inf[n], Ic1.out[n]).ks[k1] >= 0 && domMinus(Ip1.inf[n], Ic1.out[n]).ir[k1] >= 0 with {
          pure assert Ipc.inf[n] == domMinus(Ip.inf[n], Ic.out[n]);
          pure assert Ipc.inf[n].ks[k1] == Ip.inf[n].ks[k1] - Ic.out[n].ks[k1];
          pure assert Ipc.inf[n].ir[k1] == Ip.inf[n].ir[k1] - Ic.out[n].ir[k1];
          pure assert Ic.inf[n].ks[k1] >= Ic1.inf[n].ks[k1];
          pure assert edgeFn(c, Ic.inf)[n].ks[k1] != 0 ==> edgeFn(c, Ic.inf)[n].ks[k1] == Ic.inf[c].ks[k1];          
          pure assert old(edgeFn(c, Ic.inf))[n].ks[k1] >= edgeFn(c, Ic1.inf)[n].ks[k1];
          pure assert Ip1.inf[n].ks[k1] - Ic1.out[n].ks[k1] >= 0;
          pure assert Ip1.inf[n].ir[k1] - Ic1.out[n].ir[k1] >= 0;
          
        }
      }
    }
    
    pure assert forall n: Node :: n in Ic1.dom ==> domValid(domMinus(Ic1.inf[n], Ip1.out[n])) with {
      if (n in Ic1.dom) {
        pure assert forall k1: K :: domMinus(Ic1.inf[n], Ip1.out[n]).ks[k1] >= 0 && domMinus(Ic1.inf[n], Ip1.out[n]).ir[k1] >= 0 with {
          pure assert Ipc.inf[n] == domMinus(Ic.inf[n], Ip.out[n]);
          pure assert Ipc.inf[n].ks[k1] >= 0;
          pure assert Ic.inf[n].ks[k1] - Ip.out[n].ks[k1] >= 0;
          pure assert Ic.inf[n].ir[k1] - Ip.out[n].ir[k1] >= 0;
          if (lt(k1, k)) {
            pure assert n == c;
            pure assert Ip1.inf[n].ks[k1] == Ip.inf[n].ks[k1];
            pure assert ks_child(p, c, k1) ==> old(ks_child(p, c, k1));
            pure assert ks_child(p, c, k1) ==> Ip.out[c].ks[k1] == Ip.inf[p].ks[k1];
            pure assert ks_child(p, c, k1) ==> Ip1.out[c].ks[k1] == Ip1.inf[p].ks[k1];
            pure assert Ip1.out[n].ks[k1] == Ip.out[n].ks[k1];
            pure assert Ic1.inf[n].ks[k1] - Ip1.out[n].ks[k1] >= 0;
            pure assert Ic1.inf[n].ir[k1] - Ip1.out[n].ir[k1] >= 0;
          } else {
            pure assert Ic1.inf[n].ks[k1] - Ip1.out[n].ks[k1] >= 0;
          }
        }
      }
    }
  }
  
  lemma_int_comp_fold(Ip1, Ic1);
  var Ipc1 := intComp(Ip1, Ic1);

  pure assert Ipc == Ipc1 with {
    lemma_int_comp_unfold(Ip1, Ic1);
    lemma_int_comp_unfold(Ip, Ic);
    pure assert Ipc.dom == Ipc1.dom;
  pure assert forall z: Node :: Ipc.inf[z] == Ipc1.inf[z]
    && Ipc.out[z] == Ipc1.out[z]
    with {
    pure assert forall k1: K :: Ipc.inf[z].ks[k1] == Ipc1.inf[z].ks[k1]
      && Ipc.inf[z].ir[k1] == Ipc1.inf[z].ir[k1]
      && Ipc.out[z].ks[k1] == Ipc1.out[z].ks[k1]
      && Ipc.out[z].ir[k1] == Ipc1.out[z].ir[k1]
      with {
        //pure assert Ic1.out == edgeFn(c, c_inflow) && Ip1.out == edgeFn(p, Ip.inf);
        // Old and new inflow equations
        pure assert true
          && Ic1.inf[c] == domPlus(Ipc1.inf[c], Ip1.out[c]);
        pure assert true
          && Ic1.inf[c].ks[k1] == Ipc1.inf[c].ks[k1] + Ip1.out[c].ks[k1];
        pure assert true
          && Ic1.inf[c].ir[k1] == Ipc1.inf[c].ir[k1] + Ip1.out[c].ir[k1];
        pure assert true
          && Ip1.inf[p] == domPlus(Ipc1.inf[p], Ic1.out[p]);
        pure assert true
          && Ip1.inf[p].ks[k1] == Ipc1.inf[p].ks[k1] + Ic1.out[p].ks[k1];
        pure assert true
          && Ip1.inf[p].ir[k1] == Ipc1.inf[p].ir[k1] + Ic1.out[p].ir[k1];

        pure assert true
          && Ic.inf[c] == domPlus(Ipc.inf[c], Ip.out[c]);
        pure assert true
          && Ic.inf[c].ks[k1] == Ipc.inf[c].ks[k1] + Ip.out[c].ks[k1];
        pure assert true
          && Ic.inf[c].ir[k1] == Ipc.inf[c].ir[k1] + Ip.out[c].ir[k1];
        pure assert true
          && Ip.inf[p] == domPlus(Ipc.inf[p], Ic.out[p]);
        pure assert true
          && Ip.inf[p].ks[k1] == Ipc.inf[p].ks[k1] + Ic.out[p].ks[k1];
        pure assert true
          && Ip.inf[p].ir[k1] == Ipc.inf[p].ir[k1] + Ic.out[p].ir[k1];

        // Old and new outflow equations
        if (z !in Ipc.dom) {
          pure assert Ipc.out[z] == domPlus(Ip.out[z], Ic.out[z]);
          pure assert Ipc.out[z].ks[k1] == Ip.out[z].ks[k1] + Ic.out[z].ks[k1];
          pure assert Ipc.out[z].ir[k1] == Ip.out[z].ir[k1] + Ic.out[z].ir[k1];
          pure assert Ipc1.out[z] == domPlus(Ip1.out[z], Ic1.out[z]);
          pure assert Ipc1.out[z].ks[k1] == Ip1.out[z].ks[k1] + Ic1.out[z].ks[k1];
          pure assert Ipc1.out[z].ir[k1] == Ip1.out[z].ir[k1] + Ic1.out[z].ir[k1];
        }
        pure assert !lt(k1, c.keys[c.len]) ==> Ic1.inf[c].ks[k1] == Ic.inf[c].ks[k1] - Ip.out[c].ks[k1];
 
        if (ks_child(p, c, k1)) {
          pure assert ci < p.indices[c] <= p.len
            ==> p.keys.map[p.indices[c]] == old(p.keys.map)[ci + (p.indices[c] - (ci + 1))];
          pure assert ci < p.indices[c] - 1 <= p.len
            ==> p.keys.map[p.indices[c] - 1] == old(p.keys.map)[ci + ((p.indices[c] - 1) - (ci + 1))];
        }

        pure assert Ipc.out[z].ir[k1] == Ipc1.out[z].ir[k1];
        if (p.indices[z] != -1) {
          pure assert ci + 1 < old(p.indices[z]) <= old(p.len)
            ==> old(p.ptrs.map[p.indices[z]]) == z;
            pure assert ci + 1 < old(p.indices[z]) <= old(p.len)
              ==> p.ptrs[old(p.indices[z]) + 1] == z;
              if (0 <= p.indices[z] < ci + 1) {
              } else if (p.indices[z] == ci + 1) {
              } else if (ci + 1 < p.indices[z] <= p.len) {
                pure assert old(p.indices[z]) == p.indices[z] - 1;
                pure assert p.ptrs.map[p.indices[z]] == old(p.ptrs.map)[p.indices[z] - 1];
              }
        }

        if (z !in Ipc.dom) {

          pure assert Ipc.out[z].ks[k1] == Ipc1.out[z].ks[k1];
        
        }
      }
    }
    pure assert Ipc.inf == Ipc1.inf;
    pure assert Ipc.out == Ipc1.out;
    
  }
    
  return Ip1, Ic1;
}

