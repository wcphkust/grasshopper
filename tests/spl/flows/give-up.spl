/** {Spec} Flow domain setup for verifying give-up template implementations */

include "css.spl"
include "flows.spl"
include "multiset-ccm.spl"

type FlowDom = Multiset

pure function KS() returns (res: Set<K>)

/** {Spec} Definitions of predicates used in give-up template proof in Iris */

define in_inset(k, I, n) {
  I.inf[n][k] > 0
}
  
define in_outset(k, I, n) {
  I.out[n][k] > 0
}

predicate in_outsets(k: K, I: Interface)
{
  exists n: Node :: in_outset(k, I, n)
}

function keyset(I: Interface, n: Node) returns (res: Set<K>)
{
  { k: K :: in_inset(k, I, n) && !(in_outsets(k, I)) }
}

predicate globalinv(root: Node, I: Interface)
{
  intValid(I)
  && root in I.dom
  // Global interface is closed
  && (forall n: Node, k: K :: k in KS ==> !(in_outset(k, I, n)))
  && (forall n: Node :: (n == root ==> (forall k: K :: k in KS ==> in_inset(k, I, n))) &&
                 (n != root ==> (forall k: K :: k in KS ==> !(in_inset(k, I, n)))))
}