/** {Spec} Flow domain for multisets over some element type K */

include "flows.spl"
include "multipair-ccm.spl"

type FlowDom = MultiPair

lemma domMinus_inv(m1: MultiPair, m2: MultiPair)
  ensures m1 == domPlus(m2, domMinus(m1, m2))
{
  pure assert forall k: K :: m1.is[k] == domPlus(m2, domMinus(m1, m2)).is[k] with {
    pure assert m1.is[k] == m2.is[k] + (m1.is[k] - m2.is[k]);
    pure assert m1.is[k] == m2.is[k] + domMinus(m1, m2).is[k];
  }
  pure assert forall k: K :: m1.ls[k] == domPlus(m2, domMinus(m1, m2)).ls[k] with {
    pure assert m1.ls[k] == m2.ls[k] + (m1.ls[k] - m2.ls[k]);
    pure assert m1.ls[k] == m2.ls[k] + domMinus(m1, m2).ls[k];
  } 
}

pure function KS() returns (res: Set<K>)

/* Definitions of predicates used in link template proof in Iris */

define in_inset(k, I, n) {
  I.inf[n].is[k] > 0
}

define in_linkset(k, I, n) {
  I.inf[n].ls[k] > 0
}

define in_outset(k, I, n) {
  I.out[n].is[k] > 0 || I.out[n].ls[k] > 0
}

predicate in_outsets(k: K, I: Interface)
{
  exists y: Node :: in_outset(k, I, y)
}

function keyset(I: Interface, n: Node) returns (res: Set<K>)
{
  { k: K :: in_inset(k, I, n) && !(in_outsets(k, I)) }
}


/* Global invariant \phi that needs to be maintained */
pure predicate globalinv(root: Node, I: Interface) {
    intValid(I)
    && root in I.dom
    && (forall k: K, n: Node :: !(in_outset(k, I, n)))
    && (forall k: K :: k in KS ==> in_inset(k, I, root) && in_linkset(k, I, root))
    && (forall k: K, n: Node :: n != root ==> !(in_inset(k, I, n) && !(in_linkset(k, I, n))))
}

/* Node-level invariant \gamma that needs to be maintained */
pure predicate nodeinv(n: Node, I: Interface, C: Set<K>) {
   I.dom == {n} // is this needed?
   && (forall k1: K :: in_linkset(k1, I, n) && !(in_outsets(k1, I)) ==> in_inset(k1, I, n))
}

/*
lemma keyset_def(k: K, I_n: Interface, n: Node)
  requires in_inset(k, I_n, n)
  requires !(in_outsets(k, I_n))
  ensures k in keyset(I_n, n)
{
}

lemma outset_distinct(I: Interface, n: Node)
  requires intValid(I) && (exists k: K :: in_outset(k, I, n))
  ensures n !in I.dom
{
  pure assert I.out[n] != domZero;
}

lemma linkset_monotone(I: Interface, I1: Interface, I2: Interface, k: K, n: Node)
  requires intValid(I)
  requires I == intComp(I1, I2)
  requires in_linkset(k, I, n)
  requires n in I1.dom
  ensures in_linkset(k, I1, n)
{
  lemma_int_comp_unfold(I1, I2);
  pure assert I1.inf[n] == domPlus(I.inf[n], I2.out[n]);
  pure assert I1.inf[n].ls[k] == I.inf[n].ls[k] + I2.out[n].ls[k];
  pure assert I1.inf[n].is[k] == I.inf[n].is[k] + I2.out[n].is[k];
}

lemma flowint_linkset_step(I: Interface, I1: Interface, I2: Interface, k: K, n: Node)
  requires I == intComp(I1, I2) && intValid(I)
  requires n in I2.dom
  requires in_outset(k, I1, n)
  ensures in_linkset(k, I2, n) || in_inset(k, I2, n)
{
  lemma_int_comp_unfold(I1, I2);
  pure assert I2.inf[n] == domPlus(I.inf[n], I1.out[n]);
  pure assert I2.inf[n].ls[k] == I.inf[n].ls[k] + I1.out[n].ls[k];
  pure assert I2.inf[n].is[k] == I.inf[n].is[k] + I1.out[n].is[k];
}

lemma flowint_step(root: Node, I: Interface, I1: Interface, I2: Interface, k: K, n: Node)
  requires I == intComp(I1, I2)
  requires in_outset(k, I1, n)
  requires globalinv(root, I)
  ensures n in I2.dom
{
  pure assert !(in_outset(k, I, n));
  if (n !in I.dom) {
    pure assert I.out[n] == domPlus(I1.out[n], I2.out[n]);
    pure assert I.out[n].ls[k] == I1.out[n].ls[k] + I2.out[n].ls[k];
    pure assert I.out[n].is[k] == I1.out[n].is[k] + I2.out[n].is[k];
  }
}
*/