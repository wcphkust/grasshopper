/** B+ tree implementation of the link template for linearizable dictionaries. */

options "-abspreds -simplearrays -propreads -stratify"

include "flows.spl"
include "array_util.spl"


/** Flow and node domain definitions */

datatype FlowDom = fd(ks: Map<K, Int>, ir: Map<K, Int>)

pure predicate domLeq(p1: FlowDom, p2: FlowDom) {
  (forall k: K :: p1.ks[k] <= p2.ks[k]
    @(matching p1.ks[k] yields p2.ks[k]) @(matching p2.ks[k] yields p1.ks[k]))
    && (forall k: K :: p1.ir[k] <= p2.ir[k]
    @(matching p1.ir[k] yields p2.ir[k]) @(matching p2.ir[k] yields p1.ir[k]))
}

function domPlus(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
{
  fd({k: K :: p1.ks[k] + p2.ks[k]}, {k: K :: p1.ir[k] + p2.ir[k]})
}

function domMult_ks(p1: FlowDom, p2: FlowDom) returns (p: Map<K, Int>) {
  {k: K :: p1.ks[k] * p2.ks[k]}
}

function domMult_ir(p1: FlowDom, p2: FlowDom) returns (p: Map<K, Int>) {
  {k: K :: p1.ir[k] * p2.ir[k]}
}

function domMult(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
{
  fd(domMult_ks(p1, p2), domMult_ir(p1, p2))
}

function mapZero() returns(m: Map<K, Int>)
{
  { k: K :: 0 }
}

function domZero() returns(p: FlowDom)
{
  fd(mapZero, mapZero)
}


datatype InrFn = inrfnC(inrfn: Map<Node, Set<K>>, inrdom: Set<Node>) | inrfnUndef;
  
datatype NodeDom = nd(contents: Set<K>, inr: InrFn);

pure predicate ndLeq(a1: NodeDom, a2: NodeDom) {
  (forall k: K :: k in a1.contents ==> k in a2.contents)
  && (a2.inr == inrfnUndef || a1.inr != inrfnUndef && a2.inr != inrfnUndef
     && (forall x: Node :: x in a1.inr.inrdom ==> x in a2.inr.inrdom && a1.inr.inrfn[x] == a2.inr.inrfn[x]))
}

function ndJoin(a1: NodeDom, a2: NodeDom) returns (a: NodeDom)
  ensures a.contents == a1.contents ++ a2.contents

function ndBot() returns (a: NodeDom)
{
  nd({}, inrfnC({n: Node :: {}}, {}))
}


/** Definition of a node */

struct Node {
  var len: Int;
  var keys: Array<K>;
  var ptrs: Array<Node>;
  var next: Node;
  ghost var rangeLb: K;
  ghost var rangeUb: K;
  ghost var indices: Map<Node, Int>;
}

define unchanged(x) {
  x.len == old(x.len) && x.next == old(x.next)
    && x.rangeLb == old(x.rangeLb) && x.rangeUb == old(x.rangeUb)
    && x.keys == old(x.keys) && x.ptrs == old(x.ptrs)
    && x.keys.length == old(x.keys.length) && x.keys.map == old(x.keys.map)
    && x.ptrs.length == old(x.ptrs.length) && x.ptrs.map == old(x.ptrs.map)
}


/** Definition of heap representation, hrep */

// Width of the B-trees
const B: Int
axiom B > 1

// Access permissions associated with a B-link tree node x
predicate hrepSpatial(x: Node) {
  acc(x) &*& acc(x.keys) &*& acc(x.ptrs) &*& x.keys.length == 2*B && x.ptrs.length == 2*B
}

// Inflow of of a B-link tree node x
function inflow(x: Node)
  returns (i: Map<Node, FlowDom>)
  requires acc(x)
{
  { n: Node :: n != x ? domZero()
    : fd({k: K :: !lt(k, x.rangeLb) && lt(k, x.rangeUb) ? 1 : 0},
  {k: K :: !lt(k, x.rangeLb) && lt(k, top) ? 1 : 0}) }
}

// Keyset flow map of ptrs edges of a B-link tree node x
function ks_child(x: Node, u: Node) returns (m: Map<K, Int>)
  requires hrepSpatial(x)
{
 { k: K :: (x.indices[u] == 0 || !lt(k, x.keys.map[x.indices[u] - 1])) &&
    (x.indices[u] == x.len && x.next == null && lt(k, top) || lt(k, x.keys.map[x.indices[u]])) ? 1 : 0 }
}

// Flow map of next edge of a B-link tree node x
function map_next(x: Node) returns (m: Map<K, Int>)
  requires hrepSpatial(x)
{
 { k: K :: x.next != null && !lt(k, x.keys[x.len]) && lt(k, top) ? 1 : 0 }
}

// The flow map of a B-link tree node x
function flowmap(x: Node)
  returns (res: Map<Node,Map<Node, FlowDom>>)
  requires hrepSpatial(x)
{
  { n: Node ::
    n == x ?
      { u: Node ::
        0 <= x.indices[u] <= x.len ? fd(ks_child(x, u), mapZero) :
          (u == x.next ? fd(map_next(x), map_next(x)) : domZero)
      } :
    { u: Node :: domZero }
  }
}

// The outset of a B-link tree node x
function outset(x: Node)
  returns (res: Set<K>)
  requires acc(x)
{
  x.ptrs[0] == null ?
  { k: K :: x.next != null && !lt(k, x.keys[x.len]) && lt(k, top) } :
  { k: K :: !lt(k, x.rangeLb) && lt(k, top) }
}

// Show that outset is defined correctly - part 1
lemma outset_correct1(x: Node, Ix: Interface, k: K, y: Node)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires Ix.inf[x].ir[k] >= 1 || Ix.inf[x].ks[k] >= 1
  requires Ix.fm[x][y].ir[k] >= 1 || Ix.fm[x][y].ks[k] >= 1
  pure ensures k in outset(x)
{
  pure assert flowmap(x)[x][y] == Ix.fm[x][y];
}

// Show that outset is defined correctly - part 2
lemma outset_correct2(x: Node, Ix: Interface, k: K)
  returns (y: Node)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires k in outset(x)
  pure ensures Ix.inf[x].ir[k] >= 1 || Ix.inf[x].ks[k] >= 1
  pure ensures Ix.fm[x][y].ks[k] >= 1
{
  pure assert flowmap(x)[x][y] == Ix.fm[x][y] && inflow(x)[x] == Ix.inf[x];
  if (x.ptrs[0] == null) { 
    y := x.next;
    pure assert Ix.fm[x][y].ks == map_next(x);
    return y;
  } else {
    var i: Int := map_find(x.keys.map, 0, x.len, k);
    
    if (i < x.len && k == x.keys.map[i]) {  // map_find finds upper bound, we want lower
      i := i + 1;
    }

    if (i == x.len && x.next != null) {
      if (lt(k, x.keys.map[i])) {
        y := x.ptrs[i];
        pure assert flowmap(x)[x][y] == fd(ks_child(x, y), mapZero);
        return y;
      } else {
        y := x.next;
        pure assert 0 > x.indices[y] || x.indices[y] > x.len || x.ptrs[x.indices[y]] == y;
        pure assert Ix.fm[x][y] == fd(map_next(x), map_next(x));
        return y;
      }
    } else {
      pure assert i <= 0 || le(x.keys.map[i-1], k);
      y := x.ptrs[i];
      pure assert flowmap(x)[x][y] == fd(ks_child(x, y), mapZero);
      pure assert flowmap(x)[x][y].ks == ks_child(x, y);
      return y;
    }
    return y;
  }
}

// Node abstraction of a B-link tree node x with inflow inff
function nodeabs(x: Node, inff: Map<Node, FlowDom>)
  returns (res: NodeDom)
  requires hrepSpatial(x)
{
  x.ptrs[0] == null ?
    nd(set_of_map(x.keys.map, 0, x.len),
       inrfnC({n: Node :: n != x ? {} : {k: K :: inff[x].ks[k] >= 1 || inff[x].ir[k] >= 1}}, {x})) :
    nd({},
       inrfnC({n: Node :: n != x ? {} : {k: K :: inff[x].ks[k] >= 1 || inff[x].ir[k] >= 1}}, {x}))
}

// Function to compute the interface of a node
function interface(x: Node)
  returns (res: Interface)
  requires hrepSpatial(x)
{
  int(inflow(x), nodeabs(x, inflow(x)), flowmap(x), {x})
}

// These are the conditions on the fields of x for abstraction to graph to work
predicate heapGood(x: Node)
  requires hrepSpatial(x)
{
  x.next != x && 0 <= x.len < 2*B && (x.next == null ==> x.rangeUb == top)
  // Keys are sorted (TODO: internal vs. child?)
  && (forall i: Int, j: Int :: 0 <= i < j <= x.len ==> lt(x.keys[i], x.keys[j]) @(noinst i) @(noinst j))
  // Keys are in the range
  && (forall i: Int :: 0 <= i && (x.next == null && i < x.len || x.next != null && i <= x.len)
       ==> !lt(x.keys[i], x.rangeLb) && lt(x.keys[i], x.rangeUb) @(noinst i))
  // All outgoing pointers are distinct
  && (forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len
       ==> x != x.ptrs[i])
  && (forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len
       ==> x.ptrs[i] != x.next)
  && (forall i: Int, j: Int :: x.ptrs[0] != null && 0 <= i < j <= x.len
       ==> x.ptrs[i] != x.ptrs[j])
  // Indices of outgoing pointers are stored in x.indices
  && (forall n: Node :: 0 <= x.indices[n] <= x.len ==> x.ptrs.map[x.indices[n]] == n)
  && (forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len ==> x.indices[x.ptrs.map[i]] == i)
  && (x.ptrs[0] == null ==> (forall n: Node :: x.indices[n] == -1 @(noinst n)))
  && x.indices[x.next] == -1
  && x.indices[x] == -1
  // Internal nodes don't point to null
  && (forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len ==> x.ptrs[i] != null)
}

// Invariant of a B-link tree node x with flow interface I
define hrep(x, I) {
  hrepSpatial(x) &*& heapGood(x) &*& I == interface(x)
}


// The good condition
define nu(x, I) {
    // Contents subsetof keyset
    (forall k: K :: k in I.na.contents ==> I.inf[x].ks[k] >= 1)
    && (forall k: K, y: Node :: k !in I.na.contents || I.fm[x][y].ks[k] == 0)
    // Edgesets are disjoint
    && (forall k: K, y: Node, z: Node :: y == z
       || I.fm[x][y].ks[k] == 0 || I.fm[x][z].ks[k] == 0)
    // Inreach keyset subsetof inset
    && (forall k: K :: I.inf[x].ir[k] >= 1 && k !in outset(x)
       ==> I.inf[x].ks[k] >= 1)
    // If k âˆˆ inreach, then inreach edgeset is same as normal edgeset (for step)
    && (forall k: K, y: Node :: I.inf[x].ir[k] >= 1 && I.inf[x].ks[k] <= 0
       && I.fm[x][y].ks[k] >= 1 ==> I.fm[x][y].ir[k] >= 1)
    // The node label stores the actual inreach
    && I.na.inr.inrdom == {x}
    && (forall k: K :: (k in I.na.inr.inrfn[x]) == (I.inf[x].ks[k] >= 1 || I.inf[x].ir[k] >= 1))
}

// Show that if query key k is in the keyset of node x than x must be a leaf.
lemma keyset_implies_leaf(x: Node, Ix: Interface, k: K, i: Int)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires lt(k, top)
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  requires (i <= 0 || !lt(k, x.keys[i-1])) && 0 <= i <= x.len
  ensures hrep(x, Ix) &*& unchanged(x)
  ensures x.ptrs[0] == null  // x is a leaf
{
  if (x.ptrs[0] != null && i < x.len && !lt(k, x.keys[i])) {
    keyset_implies_leaf(x, Ix, k, i + 1);
    return;
  } else {
    pure assert Ix.fm == flowmap(x);
    if (x.ptrs[0] != null && lt(k, x.keys[i])) {
      pure assert Ix.fm[x][x.ptrs[i]].ks[k] == 0;
    } else if (x.ptrs[0] != null && !lt(k, x.keys[i])) {
      pure assert 0 <= x.indices[x.next] <= x.len ==> x.ptrs[x.indices[x.next]] == x.next;
      pure assert x.next == null ==> ks_child(x, x.ptrs[i])[k] == 1;
      pure assert x.next == null ==> Ix.fm[x][x.ptrs[i]].ks == ks_child(x, x.ptrs[i]);
      pure assert x.next != null ==> Ix.fm[x][x.next].ks == map_next(x);
    }
    return;
  }
}

lemma compute_interface(x: Node) returns (Ix: Interface)
  requires hrepSpatial(x)
  requires heapGood(x)
  ensures hrep(x, Ix) &*& intValid(Ix)
{
  Ix := interface(x);

  pure assert forall k: K, y: Node :: k in Ix.na.contents
      ==> Ix.inf[x].ks[k] >= 1 && Ix.fm[x][y].ks[k] == 0
  with {
    if (k in Ix.na.contents) {
      not_in_sorted_seg(x.keys.map, 0, x.len, k);
      pure assert le(x.rangeLb, k) && lt(k, x.rangeUb);
    }
  }

  pure assert forall k: K, y: Node, z: Node :: Ix.fm[x][y].ks[k] == 1 ==> y == z || Ix.fm[x][z].ks[k] == 0 with {
    if (y != z && Ix.fm[x][y].ks[k] == 1) {
      pure assert Ix.fm == flowmap(x);
      if (Ix.fm[x][z].ks[k] == 1) {
        if (x.next == y || x.next == z) {
          ghost var u: Node;
          if (x.next == y) {
            u := z;
          } else {
            u := y;
          }
          pure assert 0 <= x.indices[u] <= x.len;
          pure assert !lt(k, x.keys[x.len]);
          pure assert lt(k, x.keys[x.indices[u]]);
          pure assert !lt(x.keys[x.len], x.keys[x.indices[u]]);
        } else if (0 <= x.indices[y] <= x.len && 0 <= x.indices[z] <= x.len) {
          pure assert x.indices[z] == x.indices[y] ==> x.ptrs[x.indices[z]] == y;
          pure assert x.indices[y] < x.indices[z] && lt(x.keys.map[x.indices[y]], x.keys.map[x.indices[z]]) ||
            x.indices[z] < x.indices[y] && lt(x.keys.map[x.indices[z]], x.keys.map[x.indices[y]]);
        }
      }
    }
  }

  lemma_int_valid_fold(x, Ix);
}

/** Begin programs */

/** Initialize root note */
procedure init() returns (x: Node, I: Interface)
  ensures hrep(x, I) &*& intValid(I) == true
{
  x := new Node;
  x.keys := new Array<K>(2*B);
  x.keys[0] := bottom;
  x.ptrs := new Array<Node>(2*B);
  x.ptrs[0] := null;
  x.len := 0;
  x.next := null;
  x.rangeLb := bottom;
  x.rangeUb := top;
  x.indices := { n: Node :: -1 };

  I := interface(x);
    
  lemma_int_valid_fold(x, I);
}

/** findNext */
procedure findNext(x: Node, k: K, Ix: Interface)
  returns (n: Node)
  requires lt(k, top)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  ensures hrep(x, Ix)
  ensures n != null ==> Ix.fm[x][n].ks[k] >= 1
  ensures n == null ==> (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
{
  lemma_int_valid_unfold(x, Ix);

  pure assert Ix.fm == flowmap(x);
  if (x.ptrs[0] == null) {  // Leaf node
    if (x.next == null) {
      return null;
    }
    if (le(x.keys[x.len], k)) {
      return x.next;
    } else {
      return null;
    }
  }

  var found, i := arr_find(x.keys, x.len, k);

  if (i < x.len && k == x.keys[i]) {  // arr_find finds upper bound, we want lower
    i := i + 1;
  }

  if (i == x.len && x.next != null) {
    if (lt(k, x.keys[i])) {
      n := x.ptrs[i];
      // return n;
    } else {
      n := x.next;
      // return n;
    }
  } else {
    n := x.ptrs[i];
    // return n;
  }
  return n;
}


/** search */
procedure search(x: Node, k: K, Ix: Interface)
  returns (succ: Bool, res: Bool, Ix1: Interface)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires lt(k, top)
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures hrep(x, Ix)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (Ix1.na.contents == Ix.na.contents && (res == k in Ix.na.contents))
{
  keyset_implies_leaf(x, Ix, k, 0);

  var idx: Int;
  res, idx := arr_find(x.keys, x.len, k);

  return true, res, Ix;
}


/** insert */
procedure insert(x: Node, k: K, Ix: Interface)
  returns (succ: Bool, res: Bool, Ix1: Interface)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires lt(k, top)
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures hrep(x, Ix1)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (Ix1.na.contents == Ix.na.contents ++ {k} && (res == k !in Ix.na.contents))
{
  keyset_implies_leaf(x, Ix, k, 0);

  if (x.len < 2*B - 1) {
    ghost var m0 := x.keys.map;
    if (x.next != null) {
      x.keys[x.len + 1] := x.keys[x.len];
      set_of_map_equal(m0, x.keys.map, 0, 0, x.len);
    } else {
      x.keys[x.len + 1] := top;
      set_of_map_equal(m0, x.keys.map, 0, 0, x.len);
    }
    ghost var m := x.keys.map;
    var old_len := x.len;

    var idx, new_len := arr_insert(x.keys, k, x.len);
    x.len := new_len;

    map_insert_content_set(m, x.keys.map, idx, k, old_len, new_len);
    lemma_int_valid_unfold(x, Ix);
    Ix1 := interface(x);

    pure assert Ix1.fm == flowmap(x) && Ix.fm == old(flowmap(x));
    lemma_int_valid_fold(x, Ix1);

    pure assert intEq(Ix, Ix1) with {
      pure assert forall x1: Node, y: Node ::
        domMult(Ix.inf[x1], Ix.fm[x1][y]) == domMult(Ix1.inf[x1], Ix1.fm[x1][y]) with {
        pure assert forall k: K ::
          domMult(Ix.inf[x1], Ix.fm[x1][y]).ks[k] == domMult(Ix1.inf[x1], Ix1.fm[x1][y]).ks[k]
          && domMult(Ix.inf[x1], Ix.fm[x1][y]).ir[k] == domMult(Ix1.inf[x1], Ix1.fm[x1][y]).ir[k] with {
            pure assert
              (Ix.inf[x1].ks[k] * Ix.fm[x1][y].ks[k] == Ix1.inf[x1].ks[k] * Ix1.fm[x1][y].ks[k])
              && (Ix.inf[x1].ir[k] * Ix.fm[x1][y].ir[k] == Ix1.inf[x1].ir[k] * Ix1.fm[x1][y].ir[k]);
        }
      }
    }
    return true, old_len != new_len, Ix1;
  } else {
    return false, false, Ix;
  }
}


/** delete */
procedure delete(x: Node, k: K, Ix: Interface)
  returns (succ: Bool, res: Bool, Ix1: Interface)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires lt(k, top)
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures hrep(x, Ix1)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (Ix1.na.contents == Ix.na.contents -- {k} && (res == k in Ix.na.contents))
{
  keyset_implies_leaf(x, Ix, k, 0);

  ghost var m := x.keys.map;
  var old_len := x.len;
  
  var new_len, idx := arr_delete(x.keys, k, x.len);

  map_delete_content_set(m, x.keys.map, x.len, new_len, idx, k);

  ghost var m1 := x.keys.map;
  x.keys[new_len] := x.keys[x.len];
  set_of_map_equal(m1, x.keys.map, 0, 0, new_len);

  x.len := new_len;

  // Define Ix1 to be Ix, but with k removed from contents
  Ix1 := interface(x);
  
  lemma_int_valid_unfold(x, Ix);

  pure assert Ix1.fm == flowmap(x) && Ix.fm == old(flowmap(x));
  lemma_int_valid_fold(x, Ix1);

  pure assert intEq(Ix, Ix1) with {
    pure assert forall x1: Node, y: Node ::
      domMult(Ix.inf[x1], Ix.fm[x1][y]) == domMult(Ix1.inf[x1], Ix1.fm[x1][y]) with {
      pure assert forall k: K ::
        domMult(Ix.inf[x1], Ix.fm[x1][y]).ks[k] == domMult(Ix1.inf[x1], Ix1.fm[x1][y]).ks[k]
        && domMult(Ix.inf[x1], Ix.fm[x1][y]).ir[k] == domMult(Ix1.inf[x1], Ix1.fm[x1][y]).ir[k] with {
          pure assert
            (Ix.inf[x1].ks[k] * Ix.fm[x1][y].ks[k] == Ix1.inf[x1].ks[k] * Ix1.fm[x1][y].ks[k])
            && (Ix.inf[x1].ir[k] * Ix.fm[x1][y].ir[k] == Ix1.inf[x1].ir[k] * Ix1.fm[x1][y].ir[k]);
      }
    }
  }

  return true, old_len != new_len, Ix1;
}

/* Half split */

define emptyInt(x, Ix) {  // TODO use newInt instead
  Ix.FP == {x} && domEq(Ix.inf[x], domZero()) == true
  && (forall y: Node :: domEq(Ix.fm[x][y], domZero))
  && Ix.na == nd({}, inrfnC({n: Node :: {}}, {x}))
}

procedure half_split(c: Node, Ic: Interface, x: Node, Ix: Interface, Icx: Interface)
  returns (Ic1: Interface, Ix1: Interface, Icx1: Interface)
  requires hrep(c, Ic) &*& hrepSpatial(x) &*& emptyInt(x, Ix)
  requires intValid(Ic) == true && intValid(Ix) == true
  requires intComp(Ic, Ix) == Icx && intValid(Icx) == true
  requires x.keys.length == 2*B && x.ptrs.length == 2*B
  requires c.len == 2 * B - 1
  // Follows from x being allocated freshly
  requires domEq(Ic.fm[c][x], domZero) && c.next != x
    && (forall i: Int :: 0 <= i <= c.len ==> x != c.ptrs[i])

  ensures hrep(c, Ic1) &*& hrep(x, Ix1)
  ensures intValid(Ic1) == true && intValid(Ix1) == true
  ensures intComp(Ic1, Ix1) == Icx1 && intEq(Icx, Icx1) == true
  ensures Icx.na.contents == Icx1.na.contents
{
  var m := (c.len + 1) / 2;

  if (c.ptrs[0] == null) {  // Leaf
    lemma_int_valid_unfold(x, Ix);
    lemma_int_valid_unfold(c, Ic);
    lemma_int_valid_unfold_I(Icx);
    lemma_int_comp_unfold(c, Ic, x, Ix, Icx);
    pure assert Ic.fm == old(flowmap(c));

    arr_copy(c.keys, x.keys, m, 0, m);
    x.ptrs[0] := null;
    x.len := m - 1;
    x.next := c.next;
    c.len := m;
    c.next := x;
    x.rangeLb := c.keys[c.len];
    x.rangeUb := c.rangeUb;

    c.indices := { n: Node :: -1 };
    x.indices := { n: Node :: -1 };

    Ic1 := compute_interface(c);
    Ix1 := compute_interface(x);

    // pure assume domLeq(domMult(Ic1.inf[c], Ic1.fm[c][x]), Ix1.inf[x]);
    pure assert domLeq(domMult(Ic1.inf[c], Ic1.fm[c][x]), Ix1.inf[x]) with {
      pure assert Ix1.fm == flowmap(x) && Ic1.fm == flowmap(c);
      pure assert forall k: K :: domMult(Ic1.inf[c], Ic1.fm[c][x]).ks[k] <= Ix1.inf[x].ks[k] &&
        domMult(Ic1.inf[c], Ic1.fm[c][x]).ir[k] <= Ix1.inf[x].ir[k] with {
        pure assert
          Ic1.inf[c].ks[k] * Ic1.fm[c][x].ks[k] <= Ix1.inf[x].ks[k]
          && Ic1.inf[c].ir[k] * Ic1.fm[c][x].ir[k] <= Ix1.inf[x].ir[k]
          && domMult_ks(Ic1.inf[c], Ic1.fm[c][x])[k] <= Ix1.inf[x].ks[k]
          && domMult_ir(Ic1.inf[c], Ic1.fm[c][x])[k] <= Ix1.inf[x].ir[k]
          && domMult(Ic1.inf[c], Ic1.fm[c][x]).ks[k] <= Ix1.inf[x].ks[k]
          && domMult(Ic1.inf[c], Ic1.fm[c][x]).ir[k] <= Ix1.inf[x].ir[k];
      }
    }
    Icx1 := lemma_int_comp_fold(c, Ic1, x, Ix1);

    lemma_int_comp_unfold(c, Ic1, x, Ix1, Icx1);
    lemma_int_valid_unfold_I(Icx1);

    // pure assume Icx.na.contents == Icx1.na.contents;
    pure assert Icx.na.contents == Icx1.na.contents with {
      set_of_map_split(c.keys.map, 0, m, old(c.len));
      map_copy_content_set(c.keys.map, old(x.keys.map), x.keys.map, m, 0, m, 0, m - 1);
    }

    // pure assume forall z: Node :: domEq(Icx.inf[z], Icx1.inf[z]);
    pure assert forall z: Node :: domEq(Icx.inf[z], Icx1.inf[z]) with {
      pure assert forall k: K ::
        Icx.inf[z].ks[k] == Icx1.inf[z].ks[k] && Icx.inf[z].ir[k] == Icx1.inf[z].ir[k]
      with {
        pure assert Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + domMult(Ic.inf[c], Ic.fm[c][x]).ks[k]
          && Ix.inf[x].ir[k] == Icx.inf[x].ir[k] + domMult(Ic.inf[c], Ic.fm[c][x]).ir[k]
          && Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + Ic.inf[c].ks[k] * Ic.fm[c][x].ks[k]
          && Ix.inf[x].ir[k] == Icx.inf[x].ir[k] + Ic.inf[c].ir[k] * Ic.fm[c][x].ir[k]
          && Ix1.inf[x].ks[k] == Icx1.inf[x].ks[k] + Ic1.inf[c].ks[k] * Ic1.fm[c][x].ks[k]
          && Ix1.inf[x].ir[k] == Icx1.inf[x].ir[k] + Ic1.inf[c].ir[k] * Ic1.fm[c][x].ir[k];
      }
    }

    // pure assume forall n: Node, n1: Node ::
    //   n in Icx.FP && n1 !in Icx.FP ==>
    //   domEq(domMult(Icx.inf[n], Icx.fm[n][n1]), domMult(Icx1.inf[n], Icx1.fm[n][n1]));
    pure assert forall n: Node, n1: Node ::
      n in Icx.FP && n1 !in Icx.FP ==>
      domEq(domMult(Icx.inf[n], Icx.fm[n][n1]), domMult(Icx1.inf[n], Icx1.fm[n][n1]))
    with {
      if (n in Icx.FP && n1 !in Icx.FP) {
        pure assert forall k: K ::
          domMult(Icx.inf[n], Icx.fm[n][n1]).ks[k] == domMult(Icx1.inf[n], Icx1.fm[n][n1]).ks[k]
          && domMult(Icx.inf[n], Icx.fm[n][n1]).ir[k] == domMult(Icx1.inf[n], Icx1.fm[n][n1]).ir[k]
          && Icx.inf[n].ks[k] * Icx.fm[n][n1].ks[k] == Icx1.inf[n].ks[k] * Icx1.fm[n][n1].ks[k]
          && Icx.inf[n].ir[k] * Icx.fm[n][n1].ir[k] == Icx1.inf[n].ir[k] * Icx1.fm[n][n1].ir[k]
        with {
          // First, n == x:
          // Old and new inflow equations (only for x though)
          pure assert Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + domMult(Ic.inf[c], Ic.fm[c][x]).ks[k]
            && Ix.inf[x].ir[k] == Icx.inf[x].ir[k] + domMult(Ic.inf[c], Ic.fm[c][x]).ir[k]
            && Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + Ic.inf[c].ks[k] * Ic.fm[c][x].ks[k]
            && Ix.inf[x].ir[k] == Icx.inf[x].ir[k] + Ic.inf[c].ir[k] * Ic.fm[c][x].ir[k]
            && Ix1.inf[x].ks[k] == Icx1.inf[x].ks[k] + Ic1.inf[c].ks[k] * Ic1.fm[c][x].ks[k]
            && Ix1.inf[x].ir[k] == Icx1.inf[x].ir[k] + Ic1.inf[c].ir[k] * Ic1.fm[c][x].ir[k];
          pure assert Icx.inf[x].ks[k] == 0 && Icx.inf[x].ir[k] == 0
            && Icx1.inf[x].ks[k] == 0 && Icx1.inf[x].ir[k] == 0;
          
          // Now, n == c:
          pure assert Icx.inf[c] == Icx1.inf[c] && Icx.inf[x] == Icx1.inf[x]
            && Ic1.fm[c][x].ks[k] == map_next(c)[k] && Ic.fm[c][x].ks[k] == 0
            && Ic1.fm[c][x].ir[k] == map_next(c)[k] && Ic.fm[c][x].ir[k] == 0
            && Ix.fm[x][n1].ks[k] == 0 && Ix.fm[x][n1].ir[k] == 0;

          pure assert
            // Old flow map equation
            Icx.fm[c][n1] == domPlus(Ic.fm[c][n1], domMult(Ic.fm[c][x], Ix.fm[x][n1]))
            && Icx.fm[c][n1].ks[k] == Ic.fm[c][n1].ks[k] + domMult(Ic.fm[c][x], Ix.fm[x][n1]).ks[k]
            && Icx.fm[c][n1].ir[k] == Ic.fm[c][n1].ir[k] + domMult(Ic.fm[c][x], Ix.fm[x][n1]).ir[k]
            && Icx.fm[c][n1].ks[k] == Ic.fm[c][n1].ks[k] + Ic.fm[c][x].ks[k] * Ix.fm[x][n1].ks[k]
            && Icx.fm[c][n1].ir[k] == Ic.fm[c][n1].ir[k] + Ic.fm[c][x].ir[k] * Ix.fm[x][n1].ir[k]
          // New flow map equation
            && Icx1.fm[c][n1] == domPlus(Ic1.fm[c][n1], domMult(Ic1.fm[c][x], Ix1.fm[x][n1]))
            && Icx1.fm[c][n1].ks[k] == Ic1.fm[c][n1].ks[k] + domMult(Ic1.fm[c][x], Ix1.fm[x][n1]).ks[k]
            && Icx1.fm[c][n1].ir[k] == Ic1.fm[c][n1].ir[k] + domMult(Ic1.fm[c][x], Ix1.fm[x][n1]).ir[k]
            && Icx1.fm[c][n1].ks[k] == Ic1.fm[c][n1].ks[k] + Ic1.fm[c][x].ks[k] * Ix1.fm[x][n1].ks[k]
            && Icx1.fm[c][n1].ir[k] == Ic1.fm[c][n1].ir[k] + Ic1.fm[c][x].ir[k] * Ix1.fm[x][n1].ir[k];

          if (n1 == old(c.next)) {  // n1 was c's right sibling
            pure assert Ic.fm[c][n1].ks[k] == old(map_next(c))[k]
              && Ic.fm[c][n1].ir[k] == old(map_next(c))[k]
              && Ic1.fm[c][n1].ks[k] == 0
              && Ic1.fm[c][n1].ir[k] == 0
              && Ix1.fm[x][n1].ks[k] == map_next(x)[k]
              && Ix1.fm[x][n1].ir[k] == map_next(x)[k]
              && x.keys[x.len] == old(c.keys)[old(c.len)];
          } else {  // there was no edge from n1 to c
            pure assert Ic.fm[c][n1].ks[k] == 0 && Ic.fm[c][n1].ir[k] == 0
                && Ic1.fm[c][n1].ks[k] == 0 && Ic1.fm[c][n1].ir[k] == 0
                && Ix1.fm[x][n1].ks[k] == 0 && Ix1.fm[x][n1].ir[k] == 0;
          }
        }
      }
    }

    return Ic1, Ix1, Icx1;
    
  } else {  // Internal node
    lemma_int_valid_unfold(x, Ix);
    lemma_int_valid_unfold(c, Ic);
    lemma_int_valid_unfold_I(Icx);
    lemma_int_comp_unfold(c, Ic, x, Ix, Icx);

    ghost var clen := c.len;
    ghost var cind := c.indices;

    arr_copy(c.keys, x.keys, m, 0, c.len - m + 1);
    arr_copy_node(c.ptrs, x.ptrs, m, 0, c.len - m + 1);
    x.len := m - 1;
    c.len := m - 1;
    x.next := c.next;
    c.next := x;
    x.rangeLb := c.keys[c.len];
    x.rangeUb := c.rangeUb;
    c.indices := { n: Node :: n != x && 0 <= cind[n] < m ? cind[n] : -1 };
    x.indices := { n: Node :: n != x && m <= cind[n] <= clen ? cind[n] - m : -1 };


    // pure assume heapGood(x);
    pure assert heapGood(x) with {
      pure assert forall i: Int :: x.ptrs[0] != null && 0 <= i <= x.len ==> x.indices[x.ptrs.map[i]] == i with {
        if (0 <= i <= x.len) {
          ghost var n := old(c.ptrs.map[m + (i - 0)]);
          pure assert x.ptrs.map[i] == n;
          pure assert cind[n] == m + (i - 0);
          pure assert x.indices[n] == cind[n] - m;
        }
      }

      pure assert forall n: Node :: 0 <= x.indices[n] <= x.len ==> x.ptrs.map[x.indices[n]] == n with {
        pure assert m <= old(c.indices[n]) <= old(c.len) ==> old(c.ptrs.map[c.indices[n]]) == n;
        pure assert m <= old(c.indices[n]) <= old(c.len) ==> x.ptrs.map[old(c.indices[n]) - m] == n;
      }
    }

    // pure assume heapGood(c);
    pure assert heapGood(c) with {
      pure assert forall n: Node :: 0 <= c.indices[n] <= c.len ==> c.ptrs.map[c.indices[n]] == n with {
        pure assert 0 <= old(c.indices[n]) <= c.len ==> old(c.ptrs.map[c.indices[n]]) == n;
      }
    }
    
    Ix1 := compute_interface(x);
    Ic1 := compute_interface(c);
    
    // pure assume domLeq(domMult(Ic1.inf[c], Ic1.fm[c][x]), Ix1.inf[x]) == true;
    pure assert domLeq(domMult(Ic1.inf[c], Ic1.fm[c][x]), Ix1.inf[x]) == true with {
      pure assert Ix1.fm == flowmap(x) && Ic1.fm == flowmap(c);
      pure assert forall k: K :: domMult(Ic1.inf[c], Ic1.fm[c][x]).ks[k] <= Ix1.inf[x].ks[k] &&
        domMult(Ic1.inf[c], Ic1.fm[c][x]).ir[k] <= Ix1.inf[x].ir[k] with {
        pure assert
          Ic1.inf[c].ks[k] * Ic1.fm[c][x].ks[k] <= Ix1.inf[x].ks[k]
          && Ic1.inf[c].ir[k] * Ic1.fm[c][x].ir[k] <= Ix1.inf[x].ir[k]
          && domMult_ks(Ic1.inf[c], Ic1.fm[c][x])[k] <= Ix1.inf[x].ks[k]
          && domMult_ir(Ic1.inf[c], Ic1.fm[c][x])[k] <= Ix1.inf[x].ir[k]
          && domMult(Ic1.inf[c], Ic1.fm[c][x]).ks[k] <= Ix1.inf[x].ks[k]
          && domMult(Ic1.inf[c], Ic1.fm[c][x]).ir[k] <= Ix1.inf[x].ir[k];
      }
    }
    
    Icx1 := lemma_int_comp_fold(c, Ic1, x, Ix1);

    lemma_int_comp_unfold(c, Ic1, x, Ix1, Icx1);
    lemma_int_valid_unfold_I(Icx1);

    // pure assume forall z: Node :: domEq(Icx.inf[z], Icx1.inf[z]);
    pure assert forall z: Node :: domEq(Icx.inf[z], Icx1.inf[z]) with {
      pure assert forall k: K ::
        Icx.inf[z].ks[k] == Icx1.inf[z].ks[k] && Icx.inf[z].ir[k] == Icx1.inf[z].ir[k]
      with {
        pure assert Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + domMult(Ic.inf[c], Ic.fm[c][x]).ks[k]
          && Ix.inf[x].ir[k] == Icx.inf[x].ir[k] + domMult(Ic.inf[c], Ic.fm[c][x]).ir[k]
          && Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + Ic.inf[c].ks[k] * Ic.fm[c][x].ks[k]
          && Ix.inf[x].ir[k] == Icx.inf[x].ir[k] + Ic.inf[c].ir[k] * Ic.fm[c][x].ir[k]
          && Ix1.inf[x].ks[k] == Icx1.inf[x].ks[k] + Ic1.inf[c].ks[k] * Ic1.fm[c][x].ks[k]
          && Ix1.inf[x].ir[k] == Icx1.inf[x].ir[k] + Ic1.inf[c].ir[k] * Ic1.fm[c][x].ir[k];
      }
    }

    pure assert forall n: Node, n1: Node ::
      n in Icx.FP && n1 !in Icx.FP ==>
      domEq(domMult(Icx.inf[n], Icx.fm[n][n1]), domMult(Icx1.inf[n], Icx1.fm[n][n1]))
    with {
      if (n in Icx.FP && n1 !in Icx.FP) {
        pure assert forall k: K ::
          domMult(Icx.inf[n], Icx.fm[n][n1]).ks[k] == domMult(Icx1.inf[n], Icx1.fm[n][n1]).ks[k]
          && domMult(Icx.inf[n], Icx.fm[n][n1]).ir[k] == domMult(Icx1.inf[n], Icx1.fm[n][n1]).ir[k]
          && Icx.inf[n].ks[k] * Icx.fm[n][n1].ks[k] == Icx1.inf[n].ks[k] * Icx1.fm[n][n1].ks[k]
          && Icx.inf[n].ir[k] * Icx.fm[n][n1].ir[k] == Icx1.inf[n].ir[k] * Icx1.fm[n][n1].ir[k]
        with {
          // Old and new inflow equations (only for x though)
          pure assert Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + domMult(Ic.inf[c], Ic.fm[c][x]).ks[k]
            && Ix.inf[x].ir[k] == Icx.inf[x].ir[k] + domMult(Ic.inf[c], Ic.fm[c][x]).ir[k]
            && Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + Ic.inf[c].ks[k] * Ic.fm[c][x].ks[k]
            && Ix.inf[x].ir[k] == Icx.inf[x].ir[k] + Ic.inf[c].ir[k] * Ic.fm[c][x].ir[k]
            && Ix1.inf[x].ks[k] == Icx1.inf[x].ks[k] + Ic1.inf[c].ks[k] * Ic1.fm[c][x].ks[k]
            && Ix1.inf[x].ir[k] == Icx1.inf[x].ir[k] + Ic1.inf[c].ir[k] * Ic1.fm[c][x].ir[k];

          // Old flow map equation
          pure assert
            Icx.fm[c][n1] == domPlus(Ic.fm[c][n1], domMult(Ic.fm[c][x], Ix.fm[x][n1]))
            && Icx.fm[c][n1].ks[k] == Ic.fm[c][n1].ks[k] + domMult(Ic.fm[c][x], Ix.fm[x][n1]).ks[k]
            && Icx.fm[c][n1].ir[k] == Ic.fm[c][n1].ir[k] + domMult(Ic.fm[c][x], Ix.fm[x][n1]).ir[k]
            && Icx.fm[c][n1].ks[k] == Ic.fm[c][n1].ks[k] + Ic.fm[c][x].ks[k] * Ix.fm[x][n1].ks[k]
            && Icx.fm[c][n1].ir[k] == Ic.fm[c][n1].ir[k] + Ic.fm[c][x].ir[k] * Ix.fm[x][n1].ir[k];

          // New flow map equation
          pure assert
            Icx1.fm[c][n1] == domPlus(Ic1.fm[c][n1], domMult(Ic1.fm[c][x], Ix1.fm[x][n1]))
            && Icx1.fm[c][n1].ks[k] == Ic1.fm[c][n1].ks[k] + domMult(Ic1.fm[c][x], Ix1.fm[x][n1]).ks[k]
            && Icx1.fm[c][n1].ir[k] == Ic1.fm[c][n1].ir[k] + domMult(Ic1.fm[c][x], Ix1.fm[x][n1]).ir[k]
            && Icx1.fm[c][n1].ks[k] == Ic1.fm[c][n1].ks[k] + Ic1.fm[c][x].ks[k] * Ix1.fm[x][n1].ks[k]
            && Icx1.fm[c][n1].ir[k] == Ic1.fm[c][n1].ir[k] + Ic1.fm[c][x].ir[k] * Ix1.fm[x][n1].ir[k];

          if (0 <= old(c.indices)[n1] <= old(c.len)) {  // n1 was c's child
            if (old(c.indices)[n1] <= c.len) {  // n1 stayed at c
              pure assert c.indices[n1] == old(c.indices)[n1]
                  && Ic1.fm[c][n1].ks[k] == ks_child(c, n1)[k]
                  && Ic1.fm[c][n1].ir[k] == 0
                  && Ix1.fm[x][n1].ks[k] == 0 && Ix1.fm[x][n1].ir[k] == 0;
            } else {  // n1 moved to x
              pure assert true
                && x.ptrs.map[x.indices[n1]] == n1
                && old(c.ptrs.map)[m + x.indices[n1] - 0] == n1
                && old(c.keys.map)[m + x.indices[n1] - 0] == x.keys.map[x.indices[n1]]
                && (x.indices[n1] > 0 ==>
                    old(c.keys.map)[m + (x.indices[n1] - 1) - 0] == x.keys.map[x.indices[n1] - 1])
                && Ix1.fm[x][n1].ks[k] == 1 && x.indices[n1] != 0 ==> Ic.fm[c][n1].ks[k] == 1;
            }
          } else if (n1 == old(c.next)) {  // n1 was c's right sibling
            pure assert true
              && Ic.fm[c][n1].ks[k] == old(map_next(c))[k]
              && Ic.fm[c][n1].ir[k] == old(map_next(c))[k]
              && Ic1.fm[c][n1].ks[k] == 0
              && Ic1.fm[c][n1].ir[k] == 0
              && Ix1.fm[x][n1].ks[k] == map_next(x)[k]
              && Ix1.fm[x][n1].ir[k] == map_next(x)[k]
              && x.keys[x.len] == old(c.keys)[old(c.len)];
          } else {  // there was no edge from n1 to c
            pure assert Ic.fm[c][n1].ks[k] == 0 && Ic.fm[c][n1].ir[k] == 0
              && Ic1.fm[c][n1].ks[k] == 0 && Ic1.fm[c][n1].ir[k] == 0
              && Ix1.fm[x][n1].ks[k] == 0 && Ix1.fm[x][n1].ir[k] == 0;
          }
        }
      }
    }
    
    return Ic1, Ix1, Icx1;
  }
}

