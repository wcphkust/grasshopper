options "-abspreds"

include "../adt/lists.spl"

struct Node {
  var next: Node;
  var data: Int;
}

predicate lseg(x: Node, y: Node, lst: List) {
  (x == y &*& lst == nil) ||
  (x != y &*& lst != nil &*& acc(x) &*& x.data == lst.hd &*& lseg(x.next, y, lst.tl))
}

predicate list(x: Node, lst: List) {
  lseg(x, null, lst)
}

datatype Message = SendCons(sx: Int)
                 | ReceiveCons(rx: Int)
                 | SendNil
                 | ReceiveNil

const flagCons: Int
const flagNil: Int
axiom flagCons == 1
axiom flagNil == 0

struct Action {
  var nextAct: Action;
  var msg: Message;
}

struct Chan {
  var act: Action;
}

/////////////////////////////

predicate end(c:Chan) {
  acc(c) &*& c.act == null
}
  
predicate protocol1(act: Action, lst: List) {
     (lst != nil &*& acc(act) &*& act.msg == SendCons(lst.hd) &*& protocol1(act.nextAct, lst.tl))
  || (lst == nil &*& acc(act) &*& act.msg == SendNil &*& act.nextAct == null)
}

predicate protocol(c: Chan, lst: List) {
  acc(c) &*& protocol1(c.act, lst)
}

predicate dual_protocol1(act: Action, lst: List) {
     (lst != nil &*& acc(act) &*& act.msg == ReceiveCons(lst.hd) &*& dual_protocol1(act.nextAct, lst.tl))
  || (lst == nil &*& acc(act) &*& act.msg == ReceiveNil &*& act.nextAct == null)
}

predicate dual_protocol(c: Chan, lst: List) {
  acc(c) &*& dual_protocol1(c.act, lst)
}

/////////////////////////////

procedure new_chan(ghost lst: List)
  returns (c1: Chan, c2: Chan)
  requires emp
  ensures protocol(c1, lst) &*& dual_protocol(c2, lst)

procedure send(c: Chan, flag: Int, x: Int)
  requires acc(c) &*& acc(c.act)
  requires (c.act.msg == SendCons(x) && flag == flagCons)
        || (c.act.msg == SendNil && flag == flagNil)
  ensures acc(c) &*& c.act == old(c.act.nextAct)

procedure recv(c: Chan, implicit ghost y: Int)
  returns (flag: Int, x: Int)
  requires acc(c) &*& acc(c.act)
  requires c.act.msg == ReceiveCons(y)
        || c.act.msg == ReceiveNil
  ensures acc(c) &*& c.act == old(c.act.nextAct)
  ensures (old(c.act.msg) == ReceiveCons(x) && flag == flagCons)
       || (old(c.act.msg) == ReceiveNil && flag == flagNil)

procedure free_chan(c: Chan)
  requires end(c)
  ensures emp


/////////////////////////////

//TODO strengthen by lst
predicate lseg_grass(x: Node, y: Node) {
  acc({ z: Node :: Btwn(next, x, z, y) && z != y }) &*& Reach(next, x, y)
}

lemma lseg_to_lseg_grass(x: Node, y: Node, lst: List)
  requires lseg(x, y, lst)
  ensures lseg_grass(x, y)
{
  if (x == y) {
  } else {
    lseg_to_lseg_grass(x.next, y, lst.tl);
  }
}

/////////////////////////////

procedure thread1(c1: Chan, n: Node, ghost lst: List)
  requires protocol(c1, lst)
  requires list(n, lst)
  ensures emp
{
  if (n != null) {
    send(c1, flagCons, n.data);
    var n1 := n.next;
    free(n);
    thread1(c1, n1, lst.tl);
  } else {
    send(c1, flagNil, -1);
    free_chan(c1);
  }
}

procedure thread2(c2: Chan, ghost lst: List)
  returns (res: Node)
  requires dual_protocol(c2, lst)
  ensures list(res, lst)
{
  var flag, x := recv(c2);
  if (flag == flagCons) {
    var tail := thread2(c2, lst.tl);
    res := new Node;
    res.data := x;
    res.next := tail;
    return res;
  } else {
    free_chan(c2);
    return null;
  }
}

procedure main(n: Node, ghost lst: List)
  requires list(n, lst)
  ensures list(n, lst)
{
  assert list(n, lst) ;
  var c1,c2 := new_chan(lst);
  //assert list(n, lst) &*& protocol(c1, lst) &*& dual_protocol(c2, lst) ;
  //TODO as separate threads
  thread1(c1, n, lst);
  n := thread2(c2, lst);
}
