domain  Reference {
    function set(x: Int) : Reference
    function get(r: Reference) : Int
    function add(r: Reference, x: Int): Reference

    axiom setAxiom {
        forall i : Int :: {set(i)} get(set(i))  == i
    }

    axiom addAxiom {
        forall i : Int, r: Reference :: {add(r, i)} get(add(r, i)) == get(r) + i
    }
}

domain Message {
  function sendVal(r: Ref) : Message
  function sendExVal(r: Ref) : Message
  function receiveVal(r: Ref) : Message
  function val(m: Message) : Reference
  
  axiom sendValInjective {
    forall i : Reference :: {sendVal(i)} val(sendVal(i)) == i 
  }

  axiom sendExValInjective {
    forall i : Reference :: {sendExVal(i)} val(sendExVal(i)) == i 
  }
  
  axiom receiveValInjective {
    forall i : Reference :: {receiveVal(i)} val(receiveVal(i)) == i 
  }

  axiom sendValDistinct {
    forall i : Reference :: {sendVal(i)} sendVal(i) != receiveVal(i) && sendVal(i) != sendExVal(i)
  }

  axiom sendExValDistinct {
    forall i : Reference :: {sendExVal(i)} sendExVal(i) != sendVal(i) && sendExVal(i) != receiveVal(i)
  }

  axiom receiveValDistinct {
    forall i : Reference :: {receiveVal(i)} sendVal(i) != receiveVal(i) && receiveVal(i) != sendExVal(i)
  }
}

field act: Ref
field next: Ref
field msg: Message
field ref: Ref

predicate end(c: Ref) {
  acc(c.act) && c.act == null
}

define sendAct(a, r, na)
  acc(a.msg) && acc(a.next) && a.msg == sendVal(r) && a.next == na

define recvAct(a, r, na)
  acc(a.msg) && acc(a.next) && a.msg == receiveVal(r) && a.next == na

define sendExAct(a, r, na)
  acc(a.msg) && acc(a.next) && a.msg == sendExVal(r) && a.next == na

predicate protocol(c: Ref) {
  acc(c.act) &&
  sendExAct(c.act, val(c.act.msg), c.act.next) && recvAct(c.act.next, add(val(c.act.msg), 2), null)
}

predicate dual_protocol(c: Ref) {
  acc(c.act) &&
  recvAct(c.act, val(c.act.msg), c.act.next) && sendAct(c.act.next, add(val(c.act.msg), 2), null)
}

method new_chan()
  returns (c1: Ref, c2: Ref)
  ensures protocol(c1) && dual_protocol(c2)

method send(c: Ref, r: Ref)
  requires acc(c.act) && acc(c.act.msg) && acc(c.act.next) && acc(r.ref)
  requires c.act.msg == sendVal(r) || exists y: Reference :: c.act.msg == sendExVal(y)
  ensures acc(c.act) && c.act == old(c.act.next)
  ensures val(old(c.act.msg)) == r

method recv(c: Ref)
  returns (r: Ref)
  requires acc(c.act) && acc(c.act.msg) && acc(c.act.next)
  requires exists y: Reference :: c.act.msg == receiveVal(y)
  ensures acc(c.act) && c.act == old(c.act.next)
  ensures val(old(c.act.msg)) == r && acc(r.ref)

method thread(c2: Ref)
  requires dual_protocol(c2)
  ensures true
{
  var r : Reference
  unfold dual_protocol(c2)
  r := recv(c2)
  r.ref := r.ref + 2
  send(c2, r)
}

method main()
{
  var c1 : Ref; var c2 : Ref
  c1, c2 := new_chan()
  thread(c2)
  unfold protocol(c1)
  
  var r : Reference
  r := set(40)
  send(c1, r)
  r := recv(c1)
  assert acc(r.ref)
  //assert get(r) == 42
}
