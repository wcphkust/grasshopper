domain Message {
  function sendPing() : Message
  function sendPong() : Message
  function sendDone() : Message
  function receivePing() : Message
  function receivePong() : Message
  function receiveDone() : Message

  axiom allDifferent {
    sendPing() != sendPong() && sendPing() != sendDone() && sendPong() != sendDone() &&
    sendPing() != receivePing() && sendPing() != receivePong() && sendPing() != receiveDone() &&
    sendPong() != receivePing() && sendPong() != receivePong() && sendPong() != receiveDone() &&
    sendDone() != receivePing() && sendDone() != receivePong() && sendDone() != receiveDone() &&
    receivePing() != receivePong() && receivePing() != receiveDone() && receivePong() != receiveDone()
  }

  axiom inDomain {
    forall m:Message :: m == sendPing() || m == sendPong() || m == sendDone()
                     || m == receivePing() || m == receivePong() || m == receiveDone()
  }

}

field act: Ref
field next: Ref
field msg: Message
// For each action, we should indicate the set of allowed choices
field msgDomain: Int // use Int for quick test but should be an enum
// 0: {Ping, Done}
// 1: {Pong}


define sendPi(a, na)
  acc(a.next) && a.msg == sendPing() && a.next == na

define recvPi(a, na)
  acc(a.next) && a.msg == receivePing() && a.next == na

define sendPo(a, na)
  acc(a.next) && a.msg == sendPong() && a.next == na

define recvPo(a, na)
  acc(a.next) && a.msg == receivePong() && a.next == na

define sendDo(a, na)
  acc(a.next) && a.msg == sendDone() && a.next == na

define recvDo(a, na)
  acc(a.next) && a.msg == receiveDone() && a.next == na


predicate protocol1(a: Ref) {
  acc(a.msg) && 
  acc(a.msgDomain) && 
  a.msgDomain == 0 && (
  a.msg == sendPing() ?
    (sendPi(a, a.next) && protocol2(a.next)) :
    sendDo(a, null)
  )
}

predicate protocol2(a: Ref) {
  acc(a.msg) && 
  acc(a.msgDomain) && 
  a.msgDomain == 1 && 
  a.msg == receivePong() &&
  recvPo(a, a.next) &&
  protocol1(a.next)
}

predicate protocol(c: Ref) {
  acc(c.act) && protocol1(c.act)
}

predicate dual_protocol1(a: Ref) {
  acc(a.msg) &&
  acc(a.msgDomain) && 
  a.msgDomain == 0 && (
  a.msg == receivePing() ?
    (recvPi(a, a.next) && dual_protocol2(a.next))
    : recvDo(a, null)
  )
}

predicate dual_protocol2(a: Ref) {
  acc(a.msg) && 
  acc(a.msgDomain) && 
  a.msgDomain == 1 && 
  sendPo(a, a.next) &&
  dual_protocol1(a.next)
}

predicate dual_protocol(c: Ref) {
  acc(c.act) && dual_protocol1(c.act)
}

method new_chan()
  returns (c1: Ref, c2: Ref)
  ensures protocol(c1) && dual_protocol(c2)

method send(c: Ref, x: Int)
  requires acc(c.act) && acc(c.act.msgDomain) && acc(c.act.msg) && acc(c.act.next)
  requires c.act.msgDomain == 0 || c.act.msgDomain == 1
  requires (c.act.msgDomain == 0 ==> (x == 0 || x == 2))
        && (c.act.msgDomain == 1 ==> x == 1)
  ensures acc(c.act) && c.act == old(c.act.next)
  ensures (x == 0 ==> old(c.act.msg) == sendPing()) &&
          (x == 1 ==> old(c.act.msg) == sendPong()) &&
          (x == 2 ==> old(c.act.msg) == sendDone())

// something goes wrong with that method!?
method recv(c: Ref)
  returns (x: Int)
  requires acc(c.act) && acc(c.act.msg) && acc(c.act.next)
  requires c.act.msg == receivePing() 
        || c.act.msg == receivePong()
        || c.act.msg == receiveDone()
  ensures acc(c.act) && c.act == old(c.act.next)
  ensures (old(c.act.msg) == receivePing() && x == 0)
       || (old(c.act.msg) == receivePong() && x == 1)
       || (old(c.act.msg) == receiveDone() && x == 2)
{
    if (c.act.msg == receivePing()) {
        x := 0
    } else {
        if (c.act.msg == receivePong()) {
            x := 1
        } else {
            x := 2
        }
    }
    c.act := c.act.next
}

method thread(c2: Ref)
  requires dual_protocol(c2)
  ensures true
{
  var x : Int
  x := 0
  unfold dual_protocol(c2)
  while (x == 0)
      invariant acc(c2.act) && (x == 0 ? dual_protocol1(c2.act) : x == 2 && c2.act == null)
  {
      unfold dual_protocol1(c2.act)
      x := recv(c2)
      if (x == 0) {
        unfold dual_protocol2(c2.act)
        send(c2, 1)
      }
  }
  assert x == 2
}

method nondet() returns (res: Bool)

method main()
{
  var c1 : Ref; var c2 : Ref
  c1, c2 := new_chan()
  thread(c2)
  var nonDet: Bool
  nonDet := nondet()
  while (nonDet)
    invariant protocol(c1)
  {
    unfold protocol(c1)
    unfold protocol1(c1.act)
    send(c1, 0)
    unfold protocol2(c1.act)
    var res : Int
    res := recv(c1)
    fold protocol(c1)
    nonDet := nondet()
  }
  unfold protocol(c1)
  unfold protocol1(c1.act)
  send(c1, 2)
}
