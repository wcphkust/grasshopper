options "abspreds"

struct Ref {
  var x: Int;
}

datatype Message = Send(sr: Ref) | Receive(rr: Ref)

struct Action {
  var next: Action;
  var msg: Message;
}

struct Chan {
  var act: Action;
}
predicate end(c: Chan){
  acc(c) &*& c.act == null
}
predicate sendAct(a: Action, l: Ref, na: Action) {
  acc(a) &*& a.msg == Send(l) &*& a.next == na
}

predicate recvAct(a: Action, l: Ref, na: Action) {
  acc(a) &*& a.msg == Receive(l)  &*& a.next == na
}
    
predicate protocol(c: Chan) {
  exists l: Ref, act2: Action :: acc(c) &*& sendAct(c.act, l, act2) &*& recvAct(act2, l, null)
}

predicate dual_protocol(c: Chan) {
  exists l: Ref, act2: Action :: acc(c) &*& recvAct(c.act, l, act2) &*& sendAct(act2, l, null)
}

procedure new_chan()
  returns (c1: Chan, c2: Chan)
  ensures protocol(c1) &*& dual_protocol(c2)

procedure free_chan(c: Chan)
  requires end(c)
  ensures emp

procedure send(c: Chan, l: Ref, implicit ghost m: Ref)
  requires acc(c) &*& acc(c.act)
  requires c.act.msg == Send(m)
  ensures acc(c) &*& c.act == old(c.act.next)
  ensures l == m

procedure recv(c: Chan, implicit ghost m: Ref)
  returns (l: Ref)
  requires acc(c) &*& acc(c.act)
  requires c.act.msg == Receive(m)
  ensures acc(c) &*& c.act == old(c.act.next)
  ensures l == m

procedure prog3_thread2(c2: Chan)
  requires dual_protocol(c2)
{
  var l := recv(c2);
  var val:= l.x + 2;
  l.x := val;
  send(c2, l);
}
  
procedure fork_prog3_thread2(c2: Chan)
  requires dual_protocol(c2)
  ensures emp
  
procedure prog3_main()
{
  var c1, c2 := new_chan();
  fork_prog3_thread2(c2);
  var l := new Ref;
  l.x := 40;
  send(c1, l);
  l := recv(c1);
  free_chan(c1);
}
